======================== 
config.py 
======================== 
import os

# === Vision Model Settings ===
VISION_MODEL_PATH = "vikhyatk/moondream2"

# === ROM & Emulator Settings ===
ROM_PATH = "roms/pokemon_blue.gb"
POLLING_INTERVAL = 1  # Default polling interval in seconds
EMULATOR_PATH = "C:\\Program Files\\mGBA\\mGBA.exe"

# Screenshot location (same as ROM directory)
SCREENSHOT_PATH = os.path.join(os.path.dirname(ROM_PATH), "screenshot.png")

# === Debugging & Logging ===
LOG_DIR = os.path.join(os.getcwd(), "logs")
os.makedirs(LOG_DIR, exist_ok=True)  # Ensure log directory exists
SAVE_FRAMES = True
FRAME_SAVE_DIR = os.path.join(os.getcwd(), "logs", "frames")
os.makedirs(FRAME_SAVE_DIR, exist_ok=True)

# === Input Settings ===
KEY_MAPPING = {
    "UP": "up",
    "DOWN": "down",
    "LEFT": "left",
    "RIGHT": "right",
    "A": "z",      # Adjust based on emulator key mapping
    "B": "x",
    "START": "enter",
    "SELECT": "backspace",
    "SCREENSHOT": "F12"  # New key for triggering mGBA screenshot
}
 
 
======================== 
decision.py 
======================== 
import torch
from transformers import AutoModelForCausalLM, AutoTokenizer
import utils

class Decision:
    """
    Decision layer that leverages Llama-3.2-3B to generate concise task instructions
    from the game state and then delegates to Moondream (via Vision) to determine the
    next button press.
    """
    def __init__(self, vision, device=None):
        self.vision = vision
        self.device = device or ("cuda" if torch.cuda.is_available() else "cpu")
        self.llama_model_name = "meta-llama/Llama-3.2-3B"
        
        # Initialize Llama tokenizer and model.
        self.tokenizer = AutoTokenizer.from_pretrained(self.llama_model_name)
        self.llama_model = AutoModelForCausalLM.from_pretrained(
            self.llama_model_name,
            device_map={"": self.device}
        )
        utils.log(f"Llama model initialized on: {self.device}")

    def get_llama_instruction(self, game_state):
        """
        Uses Llama to convert a game state description into a concise instruction task.
        The instruction should direct Moondream to use its tasks/point endpoint to decide
        the appropriate button press.
        """
        prompt = f"""
You are an assistant that helps decide the next action in a Pok√©mon Blue game.
Given the following game state description:
\"\"\"{game_state}\"\"\"
Generate one concise instruction that directs Moondream to choose the appropriate
button press. End your response with the phrase: "Call Moondream point endpoint."
Do not include any extra explanation.
"""
        input_ids = self.tokenizer(prompt, return_tensors="pt").input_ids.to(self.device)
        output_ids = self.llama_model.generate(input_ids, max_new_tokens=50)
        instruction = self.tokenizer.decode(output_ids[0], skip_special_tokens=True)
        return instruction.strip()

    def get_next_action(self):
        """
        Uses Vision to obtain the game state text, then calls Llama to generate a task
        instruction. This instruction is passed to Vision (which uses Moondream) to get the final
        button press decision.
        """
        # Obtain game state description from Vision.
        game_state = self.vision.get_game_state_text()
        utils.log(f"Game state from vision: {game_state}")
        
        # Generate a concise task instruction using Llama.
        instruction = self.get_llama_instruction(game_state)
        utils.log(f"Llama instruction: {instruction}")
        
        # Pass the instruction to Vision's get_next_action, which now accepts a task_instruction.
        action = self.vision.get_next_action(task_instruction=instruction)
        utils.log(f"Decision: {action}")
        return action
 
 
======================== 
emulator.py 
======================== 
import pyautogui
import pygetwindow as gw
import time
import cv2
import numpy as np
import config
import utils
import subprocess
import psutil
import win32gui
import win32con
import os
from gamepad import Gamepad

class Emulator:
    def __init__(self):
        self.polling_interval = config.POLLING_INTERVAL
        self.window_region = None
        self.last_keypress_time = 0
        self.process = None
        self.gamepad = Gamepad()
        self.window_title = "mGBA"

        self.attach_or_launch_emulator()
        success = self.update_window_region()
        if not success:
            utils.log("WARNING: Failed to detect mGBA window. Capturing may not work correctly.")

    def is_emulator_running(self):
        if self.process is None:
            return False
        return self.process.poll() is None if hasattr(self.process, 'poll') else self.process.is_running()

    def find_existing_emulator(self):
        for proc in psutil.process_iter(attrs=["pid", "name"]):
            if "mgba" in proc.info["name"].lower():
                utils.log(f"Attached to existing mGBA process (PID {proc.info['pid']})")
                return psutil.Process(proc.info["pid"])
        return None

    def update_window_region(self):
        """
        Detect mGBA window, crop out top menu bar, etc.
        """
        try:
            windows = gw.getWindowsWithTitle(self.window_title)
            if windows:
                window = windows[0]
                if window.isMinimized:
                    win32gui.ShowWindow(window._hWnd, win32con.SW_RESTORE)
                    time.sleep(0.5)
                
                x, y, width, height = window.left, window.top, window.width, window.height

                # Approx offsets
                top_menu_height = 120
                bottom_border = 110
                side_border = 95

                content_x = x + side_border
                content_y = y + top_menu_height
                content_width = width - (side_border * 2)
                content_height = height - top_menu_height - bottom_border

                self.window_region = (content_x, content_y, content_width, content_height)
                utils.log(f"Updated mGBA window region to: {self.window_region}")

                self.debug_capture()
                return True
            else:
                utils.log("No mGBA window found to update region.")
                return False
        except Exception as e:
            utils.log(f"Error updating window region: {e}")
            return False

    def debug_capture(self):
        if self.window_region is None:
            utils.log("No window region to capture.")
            return
        try:
            screenshot = pyautogui.screenshot(region=self.window_region)
            debug_path = os.path.join(config.FRAME_SAVE_DIR, "window_debug.png")
            screenshot.save(debug_path)
            utils.log(f"Saved debug capture: {debug_path}")
        except Exception as e:
            utils.log(f"Failed to save debug capture: {e}")

    def bring_emulator_to_front(self):
        try:
            windows = gw.getWindowsWithTitle(self.window_title)
            if windows:
                window = windows[0]
                win32gui.ShowWindow(window._hWnd, win32con.SW_RESTORE)
                win32gui.SetForegroundWindow(window._hWnd)
                utils.log("Brought mGBA window to the front.")
                self.update_window_region()
            else:
                utils.log("No mGBA window found to bring to front.")
        except Exception as e:
            utils.log(f"Failed to bring mGBA to front: {e}")

    def attach_or_launch_emulator(self):
        existing_process = self.find_existing_emulator()
        if existing_process:
            self.process = existing_process
        else:
            self.launch_emulator()

    def launch_emulator(self):
        if not self.is_emulator_running():
            utils.log("Launching mGBA emulator...")
            self.process = subprocess.Popen([config.EMULATOR_PATH, config.ROM_PATH])
            time.sleep(3)
            self.bring_emulator_to_front()

    def restart_emulator_if_closed(self):
        if self.process is None or (hasattr(self.process, 'is_running') and not self.process.is_running()):
            utils.log("Emulator closed unexpectedly. Restarting...")
            self.launch_emulator()

    def capture_screen(self):
        self.restart_emulator_if_closed()
        self.bring_emulator_to_front()

        if not self.update_window_region():
            utils.log("ERROR: Failed to update window region for capture.")
            if self.window_region:
                black_frame = np.zeros((self.window_region[3], self.window_region[2], 3), dtype=np.uint8)
                return black_frame
            else:
                return np.zeros((320, 288, 3), dtype=np.uint8)  # default fallback

        screenshot = pyautogui.screenshot(region=self.window_region)
        return cv2.cvtColor(np.array(screenshot), cv2.COLOR_RGB2BGR)

    def press_key(self, key):
        current_time = time.time()
        if current_time - self.last_keypress_time < 0.3:
            return
        self.restart_emulator_if_closed()
        self.bring_emulator_to_front()
        pyautogui.press(key)
        self.last_keypress_time = current_time
        utils.log(f"Pressed key: {key}")

    def press_button(self, action):
        """
        Use the virtual gamepad to press a button.
        """
        self.restart_emulator_if_closed()
        self.bring_emulator_to_front()
        self.gamepad.press_button(action)
        utils.log(f"Pressed gamepad button: {action}")

    def trigger_screenshot(self):
        utils.log("Triggering mGBA screenshot via gamepad...")
        self.gamepad.press_button("SCREENSHOT")

if __name__ == "__main__":
    emulator = Emulator()
    utils.log("Emulator test mode: capturing frames every 5 seconds.")
    utils.log(f"Initial window region: {emulator.window_region}")
    count = 0
    while count < 5:
        frame = emulator.capture_screen()
        utils.save_frame(frame, f"test_frame_{count}.png")
        utils.log(f"Captured test frame {count}")
        count += 1
        time.sleep(5)
 
 
======================== 
gamepad.py 
======================== 
import pyvjoy
import time
import config
import utils

class Gamepad:
    def __init__(self):
        """Initialize virtual gamepad using vJoy."""
        self.j = pyvjoy.VJoyDevice(1)  # Use vJoy Device 1

        # Updated Gamepad Mapping
        self.button_map = {
            "A": 1,
            "B": 2,
            "START": 8,
            "SELECT": 7,
            "UP": 3,
            "DOWN": 4,
            "LEFT": 5,
            "RIGHT": 6,
            "SCREENSHOT": 9  # New button mapped for mGBA screenshot
        }

        self.reset()

    def reset(self):
        """Reset all buttons on the virtual gamepad."""
        self.j.reset()
        self.j.reset_buttons()
        utils.log("vJoy gamepad reset to default state.")

    def press_button(self, action, is_manual=False):
        """Press a mapped button using vJoy.
        
        If is_manual=True, wait 5 seconds before pressing.
        """
        if action in self.button_map:
            button_id = self.button_map[action]

            if is_manual:
                utils.log(f"Waiting 5 seconds before pressing: {action}")
                time.sleep(5)

            utils.log(f"Pressing gamepad button: {action} (vJoy Button {button_id})")
            self.j.set_button(button_id, 1)
            time.sleep(0.2)  # Hold duration
            self.j.set_button(button_id, 0)  # Release button

        else:
            utils.log(f"Invalid action '{action}' sent to gamepad.")

if __name__ == "__main__":
    gp = Gamepad()
    print("Manual Gamepad Test Mode: Enter button names to simulate input.")
    while True:
        action = input("Enter button (A, B, START, SELECT, UP, DOWN, LEFT, RIGHT, SCREENSHOT) or 'exit': ").strip().upper()
        if action == "EXIT":
            break
        gp.press_button(action, is_manual=True)
 
 
======================== 
main.py 
======================== 
import time
import utils
import config
from emulator import Emulator
from vision import Vision
from decision import Decision

class PokemonTrainerAI:
    def __init__(self):
        self.emulator = Emulator()         # For capturing screen & gamepad button presses
        self.vision = Vision(self.emulator)  # Moondream-based vision+decision
        self.decision = Decision(self.vision)

        self.action_count = 0
        self.game_completed = False

    def run(self):
        utils.log("Starting Pok√©mon Blue AI training (All Moondream + Llama)...")
        while not self.game_completed:
            # Get next action from Decision (which calls Vision and then Moondream)
            action = self.decision.get_next_action()
            # Use the gamepad to press the corresponding button
            self.emulator.press_button(action)
            self.action_count += 1

            # Optional: Check if we see "Hall of Fame" in the screen text
            game_state_text = self.vision.get_game_state_text()
            if "Hall of Fame" in game_state_text:
                utils.log(f"Game completed in {self.action_count} actions!")
                self.game_completed = True

            time.sleep(config.POLLING_INTERVAL)

if __name__ == "__main__":
    PokemonTrainerAI().run()
 
 
======================== 
utils.py 
======================== 
import os
import cv2
import datetime
import config

def log(message):
    """Logs a message with a timestamp."""
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    log_message = f"[{timestamp}] {message}"
    print(log_message)
    log_file = os.path.join(config.LOG_DIR, "log.txt")
    with open(log_file, "a") as f:
        f.write(log_message + "\n")

def save_frame(frame, filename=None):
    """Saves a frame for debugging if enabled."""
    if config.SAVE_FRAMES:
        if filename is None:
            filename = f"frame_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
        filepath = os.path.join(config.FRAME_SAVE_DIR, filename)
        cv2.imwrite(filepath, frame)
        log(f"Saved frame: {filepath}")

def map_action_to_key(action):
    """Maps an action string to the emulator's keybinds."""
    return config.KEY_MAPPING.get(action.upper(), None)
 
 
======================== 
vision.py 
======================== 
import torch
from transformers import AutoModelForCausalLM, AutoProcessor
import config
import utils
import cv2
import numpy as np
import os
from PIL import Image

class Vision:
    """
    Updated Moondream-based vision & decision class.
    This class captures the screen from the emulator and uses the Moondream model
    to choose the next button press based on the current game state.
    It also accepts an optional task_instruction from Llama.
    """
    def __init__(self, emulator=None):
        self.emulator = emulator
        self.device = "cuda" if torch.cuda.is_available() else "cpu"

        # Load Moondream
        self.processor = AutoProcessor.from_pretrained(
            config.VISION_MODEL_PATH,
            trust_remote_code=True
        )
        self.model = AutoModelForCausalLM.from_pretrained(
            config.VISION_MODEL_PATH,
            revision="2025-01-09",
            trust_remote_code=True,
            device_map={"": self.device}
        )
        utils.log(f"Moondream model initialized on: {self.device}")

        # Valid button actions
        self.valid_buttons = ["UP", "DOWN", "LEFT", "RIGHT", "A", "B", "START", "SELECT"]

        # Base Moondream prompt with clear instructions
        self.base_prompt = """
You are playing Pok√©mon Blue on a Game Boy. Your goal is to complete the game as efficiently as possible by selecting the best button press for the current situation.

### Game Controls:
- UP, DOWN, LEFT, RIGHT ‚Üí Move the player character or navigate menus.
- A ‚Üí Confirm selections, talk to NPCs, progress dialogue.
- B ‚Üí Cancel selections, close menus, or speed up text if needed.
- START ‚Üí Start the game from the title screen or open the main menu.
- SELECT ‚Üí Open secondary menus in specific cases.

### Decision Strategy:
1. **Title Screen:**  
   If the screen shows "Blue Version" or the Pok√©mon logo, PRESS START. Do NOT press A.
2. **Dialogue/Reading Text:**  
   If text is present, press A to continue (unless you are in a menu).
3. **Menus:**  
   Use UP/DOWN to navigate and A to confirm.
4. **Battles:**  
   Use directional buttons (UP/DOWN/LEFT/RIGHT) to choose moves or switch options and confirm with A.
5. **Overworld Movement:**  
   Use directional buttons to move around.

### IMPORTANT:
Return ONLY a single valid action (UP, DOWN, LEFT, RIGHT, A, B, START, SELECT) with no extra text.
Do not output any additional words.
"""

    def capture_screen(self):
        """
        Capture the emulator screen as a PIL image.
        """
        if not self.emulator:
            utils.log("WARNING: No emulator provided to Vision. Returning blank image.")
            return Image.new('RGB', (160, 144), color=(0, 0, 0))
        frame = self.emulator.capture_screen()
        return Image.fromarray(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB))
    
    def get_game_state_text(self):
        """
        Return a descriptive text about the current screen for debugging/logging.
        """
        image = self.capture_screen()
        encoded = self.model.encode_image(image)
        caption = self.model.caption(encoded, length="normal")["caption"]
        utils.log(f"Moondream Screen Caption: {caption}")
        return caption

    def get_next_action(self, task_instruction=None):
        """
        Use the Moondream model to choose the next button press.
        If a task_instruction (from Llama) is provided, it is appended to the prompt.
        If the response is invalid, post-process and retry until a valid action is returned.
        """
        # Build the prompt. If a task_instruction exists, append it.
        if task_instruction:
            prompt = self.base_prompt + "\n" + task_instruction
        else:
            prompt = self.base_prompt

        while True:
            image = self.capture_screen()
            encoded = self.model.encode_image(image)
            
            response = self.model.query(encoded, prompt)["answer"]
            utils.log(f"Moondream Raw Decision: {response}")
            
            # Clean and uppercase the response
            action = response.strip().upper()
            
            # Post-process: if Moondream outputs "BLUE VERSION", override to "START"
            if "BLUE VERSION" in action:
                utils.log("Detected 'BLUE VERSION' in response, overriding decision to 'START'.")
                action = "START"
            
            # Attempt to map partial matches if the action is not directly valid.
            if action not in self.valid_buttons:
                for button in self.valid_buttons:
                    if button in action:
                        utils.log(f"Mapping partial match '{action}' to '{button}'.")
                        action = button
                        break
            
            if action in self.valid_buttons:
                return action
            else:
                utils.log(f"Invalid Moondream action '{action}'. Retrying...")
                continue
 
 
