======================== 
config.py 
======================== 
import os

# === Vision Model Settings ===
VISION_MODEL_PATH = "vikhyatk/moondream2"

# === Memory Optimization Settings ===
# Enable memory optimizations (8-bit quantization and offloading)
USE_8BIT_QUANTIZATION = True
USE_OFFLOADING = True

# === ROM & Emulator Settings ===
ROM_PATH = "roms/pokemon_blue.gb"
POLLING_INTERVAL = 0.8  # Reduced polling interval for faster gameplay
EMULATOR_PATH = "C:\\Program Files\\mGBA\\mGBA.exe"

# Screenshot location (same as ROM directory)
SCREENSHOT_PATH = os.path.join(os.path.dirname(ROM_PATH), "screenshot.png")

# === Debugging & Logging ===
LOG_DIR = os.path.join(os.getcwd(), "logs")
os.makedirs(LOG_DIR, exist_ok=True)  # Ensure log directory exists
SAVE_FRAMES = True
FRAME_SAVE_DIR = os.path.join(os.getcwd(), "logs", "frames")
os.makedirs(FRAME_SAVE_DIR, exist_ok=True)

# Reduce frame logging frequency to improve performance
FRAME_LOGGING_FREQUENCY = 20  # Save only every Nth frame

# === Cache Settings ===
# Enhanced caching to reduce model calls
VISION_CACHE_SIZE = 10
DECISION_CACHE_SIZE = 20
ENABLE_SIMILARITY_CACHE = True  # Enable fuzzy matching for cache hits

# === Input Settings ===
KEY_MAPPING = {
    "UP": "up",
    "DOWN": "down",
    "LEFT": "left",
    "RIGHT": "right",
    "A": "z",      # Adjust based on emulator key mapping
    "B": "x",
    "START": "enter",
    "SELECT": "backspace",
    "SCREENSHOT": "F12"  # New key for triggering mGBA screenshot
}

# === Performance Settings ===
# Performance optimization flags
TORCH_COMPILE = True      # Use torch.compile for models if available
HALF_PRECISION = True     # Use FP16 precision
LOW_CPU_USAGE = True      # Enable low CPU memory usage 
 
======================== 
decision.py 
======================== 
import torch
from transformers import AutoModelForCausalLM, AutoTokenizer, StoppingCriteria, StoppingCriteriaList, BitsAndBytesConfig
import utils
import config

class StopOnTokens(StoppingCriteria):
    def __init__(self, stop_token_ids):
        self.stop_token_ids = stop_token_ids
    
    def __call__(self, input_ids, scores, **kwargs):
        return any(input_ids[0][-1] == stop_id for stop_id in self.stop_token_ids)

class Decision:
    """
    Decision layer that leverages Llama-3.2-3B to generate concise task instructions
    from the game state and then delegates to Moondream (via Vision) to determine the
    next button press. Incorporates walkthrough context to maintain consistency in state transitions.
    """
    def __init__(self, vision, device=None):
        self.vision = vision
        self.device = device or ("cuda" if torch.cuda.is_available() else "cpu")
        self.llama_model_name = "meta-llama/Llama-3.2-3B"
        
        self.tokenizer = AutoTokenizer.from_pretrained(self.llama_model_name)
        
        quantization_config = BitsAndBytesConfig(
            load_in_8bit=True,
            llm_int8_enable_fp32_cpu_offload=False
        )
        
        self.llama_model = AutoModelForCausalLM.from_pretrained(
            self.llama_model_name,
            device_map="cuda",
            quantization_config=quantization_config,
            torch_dtype=torch.float16,
            low_cpu_mem_usage=True
        )
        if torch.cuda.is_available() and config.TORCH_COMPILE:
            self.llama_model = torch.compile(self.llama_model)
        
        stop_words = [".", "\n"]
        stop_token_ids = [self.tokenizer.encode(word, add_special_tokens=False)[-1] for word in stop_words]
        self.stopping_criteria = StoppingCriteriaList([StopOnTokens(stop_token_ids)])
        
        utils.log(f"Llama model initialized on: {self.device} with 8-bit quantization (no CPU offload) and float16 precision")
        
        self.prompt_templates = self._create_prompt_templates()
        
        self.current_state = "UNKNOWN"
        self.previous_states = []
        self.state_transitions = 0
        
        self.instruction_cache = {}
        self.cache_size = 20  

        self.common_state_actions = {
            "TITLE_SCREEN": "START",
            "DIALOGUE": "A",
            "INTRO_SEQUENCE": "A",
            "ITEM_FOUND": "A",
            "HEALING": "A",
            "EVOLUTION": "A"
        }

    def _create_prompt_templates(self):
        return {
            "TITLE_SCREEN": "You're at the Pokémon Blue title screen. Respond with: 'Press START button to begin the game.'",
            "INTRO_SEQUENCE": "You're in Professor Oak's introduction. Respond with: 'Press A button to continue dialogue.'",
            "DIALOGUE": "You're in a dialogue screen. Respond with: 'Press A button to continue dialogue.'",
            "MENU": "You're navigating a menu. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Press A', 'Press B'.",
            "OVERWORLD": "You're exploring the overworld. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Move LEFT', 'Move RIGHT', 'Press A'.",
            "BATTLE": "You're in a Pokémon battle. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Move LEFT', 'Move RIGHT', 'Press A', 'Press B'.",
            "WILD_BATTLE": "You're in a wild Pokémon battle. Choose 'FIGHT' for moves, or other options. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Move LEFT', 'Move RIGHT', 'Press A', 'Press B'.",
            "TRAINER_BATTLE": "You're in a trainer battle. Choose your moves wisely. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Move LEFT', 'Move RIGHT', 'Press A', 'Press B'.",
            "GYM_LEADER_BATTLE": "You're battling a Gym Leader. This is an important battle for a badge. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Move LEFT', 'Move RIGHT', 'Press A', 'Press B'.",
            "CAVE": "You're exploring a cave in Pokémon Blue. Watch for wild Pokémon encounters and look for items. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Move LEFT', 'Move RIGHT', 'Press A', 'Press START' (to access menu).",
            "DARK_CAVE": "You're in a dark cave with very limited visibility. Respond with: 'Press START to access menu for Flash or use directional navigation.'",
            "MT_MOON": "You're in Mt. Moon. Watch for Zubat encounters and look for items and fossil researchers. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Move LEFT', 'Move RIGHT', 'Press A', 'Press START'.",
            "ROCK_TUNNEL": "You're in Rock Tunnel. This area is complex with many trainers. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Move LEFT', 'Move RIGHT', 'Press A', 'Press START'.",
            "VICTORY_ROAD": "You're in Victory Road. This is a challenging cave with strength puzzles. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Move LEFT', 'Move RIGHT', 'Press A', 'Press START'.",
            "BUILDING": "You're inside a building. Look for NPCs to talk to or items. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Move LEFT', 'Move RIGHT', 'Press A'.",
            "POKEMON_CENTER": "You're in a Pokémon Center. Talk to Nurse Joy to heal or use the PC. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Move LEFT', 'Move RIGHT', 'Press A'.",
            "POKEMON_MART": "You're in a Pokémon Mart. Talk to the clerk to buy items. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Move LEFT', 'Move RIGHT', 'Press A'.",
            "GYM": "You're in a Pokémon Gym. Navigate to the Gym Leader while defeating trainers. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Move LEFT', 'Move RIGHT', 'Press A'.",
            "ITEM_FOUND": "You've found an item. Respond with: 'Press A to pick up the item.'",
            "HEALING": "Your Pokémon are being healed. Respond with: 'Press A to continue.'",
            "EVOLUTION": "Your Pokémon is evolving! Respond with: 'Press A to continue evolution' or 'Press B to cancel evolution'.",
            "FISHING": "You're using a fishing rod. Wait for a bite. Respond with: 'Press A when there's a bite.'",
            "POKEMON_MENU": "You're in the Pokémon menu. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Press A to select', 'Press B to exit'.",
            "ITEM_MENU": "You're in the Item menu. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Press A to use item', 'Press B to exit'.",
            "SAVE_MENU": "You're at the save prompt. Respond with: 'Press A to save' or 'Press B to cancel'.",
            "STRENGTH_PUZZLE": "You're at a strength puzzle. You need to push boulders. Respond with: 'Press A to use Strength' or 'Move in the direction to push boulder'.",
            "CUT_OBSTACLE": "There's a small tree blocking your path. Respond with: 'Press A to use Cut' if facing the tree.",
            "SURF_WATER": "You're at a body of water. Respond with: 'Press A to use Surf' if facing the water."
        }

    def detect_game_state(self, game_state_text):
        game_state_upper = game_state_text.upper()
        if ("PROFESSOR" in game_state_upper or "OAK" in game_state_upper) and "INTRO" in game_state_upper:
            return "INTRO_SEQUENCE"
        if "BLUE VERSION" in game_state_upper or "TITLE SCREEN" in game_state_upper:
            return "TITLE_SCREEN"
        if "GYM LEADER" in game_state_upper and "BATTLE" in game_state_upper:
            return "GYM_LEADER_BATTLE"
        if "TRAINER" in game_state_upper and "BATTLE" in game_state_upper:
            return "TRAINER_BATTLE"
        if "WILD" in game_state_upper and "BATTLE" in game_state_upper:
            return "WILD_BATTLE"
        if "BATTLE" in game_state_upper or "FIGHT" in game_state_upper:
            return "BATTLE"
        if ("DARK" in game_state_upper or "CAN'T SEE" in game_state_upper) and ("CAVE" in game_state_upper or "TUNNEL" in game_state_upper):
            return "DARK_CAVE"
        if "MT MOON" in game_state_upper or "MT. MOON" in game_state_upper:
            return "MT_MOON"
        if "ROCK TUNNEL" in game_state_upper:
            return "ROCK_TUNNEL"
        if "VICTORY ROAD" in game_state_upper:
            return "VICTORY_ROAD"
        if "CAVE" in game_state_upper:
            return "CAVE"
        if "POKEMON CENTER" in game_state_upper or "POKÉMON CENTER" in game_state_upper:
            return "POKEMON_CENTER"
        if "MART" in game_state_upper or "SHOP" in game_state_upper or "STORE" in game_state_upper:
            return "POKEMON_MART"
        if "GYM" in game_state_upper:
            return "GYM"
        if "BUILDING" in game_state_upper or "HOUSE" in game_state_upper or "INDOOR" in game_state_upper:
            return "BUILDING"
        if "FOUND" in game_state_upper and "ITEM" in game_state_upper:
            return "ITEM_FOUND"
        if "HEALING" in game_state_upper or "NURSE JOY" in game_state_upper:
            return "HEALING"
        if "EVOLVING" in game_state_upper or "EVOLUTION" in game_state_upper:
            return "EVOLUTION"
        if "FISHING" in game_state_upper or "FISHING ROD" in game_state_upper:
            return "FISHING"
        if "POKEMON" in game_state_upper and "MENU" in game_state_upper:
            return "POKEMON_MENU"
        if "ITEM" in game_state_upper and "MENU" in game_state_upper:
            return "ITEM_MENU"
        if "SAVE" in game_state_upper:
            return "SAVE_MENU"
        if "MENU" in game_state_upper or "OPTION" in game_state_upper:
            return "MENU"
        if "BOULDER" in game_state_upper and "STRENGTH" in game_state_upper:
            return "STRENGTH_PUZZLE"
        if "TREE" in game_state_upper and "CUT" in game_state_upper:
            return "CUT_OBSTACLE"
        if ("WATER" in game_state_upper or "LAKE" in game_state_upper or "OCEAN" in game_state_upper) and "SURF" in game_state_upper:
            return "SURF_WATER"
        if "TEXT" in game_state_upper or "DIALOGUE" in game_state_upper:
            return "DIALOGUE"
        return "OVERWORLD"

    def get_llama_instruction(self, game_state):
        if hasattr(self.vision, 'current_environment') and self.vision.current_environment != "UNKNOWN":
            if self.vision.environment_confidence > 0.7:
                new_state = self.vision.current_environment
                utils.log(f"Using Vision's environment detection: {new_state} (confidence: {self.vision.environment_confidence:.2f})")
            else:
                new_state = self.detect_game_state(game_state)
        else:
            new_state = self.detect_game_state(game_state)
        
        # If new_state is ambiguous but previous state was cave (or dark cave) from walkthrough context, force cave state.
        if new_state == "OVERWORLD" and self.current_state in ["CAVE", "DARK_CAVE"]:
            utils.log("Forcing cave state from previous state due to walkthrough context.")
            new_state = self.current_state
        
        if new_state != self.current_state:
            self.previous_states.append(self.current_state)
            if len(self.previous_states) > 5:
                self.previous_states.pop(0)
            self.state_transitions += 1
            utils.log(f"State transition: {self.current_state} -> {new_state}")
            self.current_state = new_state

        if new_state in self.common_state_actions:
            return f"Press {self.common_state_actions[new_state]} button."

        cache_key = f"{new_state}:{hash(game_state[:100])}"
        if cache_key in self.instruction_cache:
            cached_instruction = self.instruction_cache[cache_key]
            utils.log(f"Using cached instruction for {new_state}: {cached_instruction}")
            return cached_instruction

        prompt = self.prompt_templates.get(new_state, self.prompt_templates["OVERWORLD"])
        utils.log(f"Generating instruction for state: {new_state}")

        input_ids = self.tokenizer(prompt, return_tensors="pt").input_ids.to(self.device).to(torch.long)

        with torch.inference_mode():
            temperature = 0.5
            if new_state in ["DARK_CAVE", "MT_MOON", "ROCK_TUNNEL", "VICTORY_ROAD"]:
                temperature = 0.3
            elif new_state in ["BATTLE", "WILD_BATTLE", "TRAINER_BATTLE", "GYM_LEADER_BATTLE"]:
                temperature = 0.4
                
            output = self.llama_model.generate(
                input_ids, 
                max_new_tokens=25,
                temperature=temperature,
                top_p=0.85,
                repetition_penalty=1.1,
                stopping_criteria=self.stopping_criteria,
                pad_token_id=self.tokenizer.eos_token_id
            )

        instruction = self.tokenizer.decode(output[0][input_ids.shape[1]:], skip_special_tokens=True).strip()
        utils.log(f"Llama instruction: {instruction}")

        if len(self.instruction_cache) >= self.cache_size:
            oldest_key = next(iter(self.instruction_cache))
            del self.instruction_cache[oldest_key]
        self.instruction_cache[cache_key] = instruction

        return instruction if instruction else "Press A button to continue."
    
    def handle_dark_cave(self):
        if len(self.previous_states) >= 3 and all(state == "DARK_CAVE" for state in self.previous_states[-3:]):
            utils.log("Stuck in dark cave, attempting to access Flash through menu")
            return "START"
        
        last_actions = getattr(self, '_last_dark_cave_actions', [])
        if not last_actions:
            utils.log("Starting dark cave navigation with RIGHT direction")
            self._last_dark_cave_actions = ["RIGHT"]
            return "RIGHT"
            
        last_action = last_actions[-1]
        if len(last_actions) >= 2 and last_actions[-1] == last_actions[-2]:
            directions = ["UP", "RIGHT", "DOWN", "LEFT"]
            current_idx = directions.index(last_action)
            next_idx = (current_idx + 1) % 4
            next_action = directions[next_idx]
            utils.log(f"Changing direction in dark cave from {last_action} to {next_action}")
            last_actions.append(next_action)
            self._last_dark_cave_actions = last_actions[-5:] if len(last_actions) > 5 else last_actions
            return next_action
        else:
            last_actions.append(last_action)
            self._last_dark_cave_actions = last_actions[-5:] if len(last_actions) > 5 else last_actions
            return last_action

    def get_next_action(self):
        game_state = self.vision.get_game_state_text()
        utils.log(f"Game state from vision: {game_state}")

        if "TITLE SCREEN" in game_state.upper() or self.current_state == "TITLE_SCREEN":
            return "START"
            
        if self.current_state == "DARK_CAVE":
            return self.handle_dark_cave()

        instruction = self.get_llama_instruction(game_state)
        utils.log(f"Llama instruction: {instruction}")

        if hasattr(self.vision, 'get_next_action') and callable(getattr(self.vision, 'get_next_action')):
            action = self.vision.get_next_action(instruction)
            utils.log(f"Vision-based action with instruction: {action}")
            return action

        action = instruction.upper()
        if "PRESS A" in action:
            return "A"
        if "PRESS B" in action:
            return "B"
        if "PRESS START" in action:
            return "START"
        if "MOVE UP" in action:
            return "UP"
        if "MOVE DOWN" in action:
            return "DOWN"
        if "MOVE LEFT" in action:
            return "LEFT"
        if "MOVE RIGHT" in action:
            return "RIGHT"
        
        return self.get_next_action()
 
 
======================== 
emulator.py 
======================== 
import pyautogui
import pygetwindow as gw
import time
import cv2
import numpy as np
import config
import utils
import subprocess
import psutil
import win32gui
import win32con
import os
from gamepad import Gamepad

class Emulator:
    def __init__(self):
        self.polling_interval = config.POLLING_INTERVAL
        self.window_region = None
        self.last_keypress_time = 0
        self.process = None
        self.gamepad = Gamepad()
        self.window_title = "mGBA"

        self.attach_or_launch_emulator()
        success = self.update_window_region()
        if not success:
            utils.log("WARNING: Failed to detect mGBA window. Capturing may not work correctly.")

    def is_emulator_running(self):
        if self.process is None:
            return False
        return self.process.poll() is None if hasattr(self.process, 'poll') else self.process.is_running()

    def find_existing_emulator(self):
        for proc in psutil.process_iter(attrs=["pid", "name"]):
            if "mgba" in proc.info["name"].lower():
                utils.log(f"Attached to existing mGBA process (PID {proc.info['pid']})")
                return psutil.Process(proc.info["pid"])
        return None

    def update_window_region(self):
        """
        Detect mGBA window, crop out top menu bar, etc.
        """
        try:
            windows = gw.getWindowsWithTitle(self.window_title)
            if windows:
                window = windows[0]
                if window.isMinimized:
                    win32gui.ShowWindow(window._hWnd, win32con.SW_RESTORE)
                    time.sleep(0.5)
                
                x, y, width, height = window.left, window.top, window.width, window.height

                # Approx offsets
                top_menu_height = 120
                bottom_border = 88
                side_border = 80

                content_x = x + side_border
                content_y = y + top_menu_height
                content_width = width - (side_border * 2)
                content_height = height - top_menu_height - bottom_border

                self.window_region = (content_x, content_y, content_width, content_height)
                utils.log(f"Updated mGBA window region to: {self.window_region}")

                self.debug_capture()
                return True
            else:
                utils.log("No mGBA window found to update region.")
                return False
        except Exception as e:
            utils.log(f"Error updating window region: {e}")
            return False

    def debug_capture(self):
        if self.window_region is None:
            utils.log("No window region to capture.")
            return
        try:
            screenshot = pyautogui.screenshot(region=self.window_region)
            debug_path = os.path.join(config.FRAME_SAVE_DIR, "window_debug.png")
            screenshot.save(debug_path)
            utils.log(f"Saved debug capture: {debug_path}")
        except Exception as e:
            utils.log(f"Failed to save debug capture: {e}")

    def bring_emulator_to_front(self):
        try:
            windows = gw.getWindowsWithTitle(self.window_title)
            if windows:
                window = windows[0]
                win32gui.ShowWindow(window._hWnd, win32con.SW_RESTORE)
                win32gui.SetForegroundWindow(window._hWnd)
                utils.log("Brought mGBA window to the front.")
                self.update_window_region()
            else:
                utils.log("No mGBA window found to bring to front.")
        except Exception as e:
            utils.log(f"Failed to bring mGBA to front: {e}")

    def attach_or_launch_emulator(self):
        existing_process = self.find_existing_emulator()
        if existing_process:
            self.process = existing_process
        else:
            self.launch_emulator()

    def launch_emulator(self):
        if not self.is_emulator_running():
            utils.log("Launching mGBA emulator...")
            self.process = subprocess.Popen([config.EMULATOR_PATH, config.ROM_PATH])
            time.sleep(3)
            self.bring_emulator_to_front()

    def restart_emulator_if_closed(self):
        if self.process is None or (hasattr(self.process, 'is_running') and not self.process.is_running()):
            utils.log("Emulator closed unexpectedly. Restarting...")
            self.launch_emulator()

    def capture_screen(self):
        self.restart_emulator_if_closed()
        self.bring_emulator_to_front()

        if not self.update_window_region():
            utils.log("ERROR: Failed to update window region for capture.")
            if self.window_region:
                black_frame = np.zeros((self.window_region[3], self.window_region[2], 3), dtype=np.uint8)
                return black_frame
            else:
                return np.zeros((320, 288, 3), dtype=np.uint8)  # default fallback

        screenshot = pyautogui.screenshot(region=self.window_region)
        return cv2.cvtColor(np.array(screenshot), cv2.COLOR_RGB2BGR)

    def press_key(self, key):
        current_time = time.time()
        if current_time - self.last_keypress_time < 0.3:
            return
        self.restart_emulator_if_closed()
        self.bring_emulator_to_front()
        pyautogui.press(key)
        self.last_keypress_time = current_time
        utils.log(f"Pressed key: {key}")

    def press_button(self, action):
        """
        Use the virtual gamepad to press a button.
        """
        self.restart_emulator_if_closed()
        self.bring_emulator_to_front()
        self.gamepad.press_button(action)
        utils.log(f"Pressed gamepad button: {action}")

    def trigger_screenshot(self):
        utils.log("Triggering mGBA screenshot via gamepad...")
        self.gamepad.press_button("SCREENSHOT")

if __name__ == "__main__":
    emulator = Emulator()
    utils.log("Emulator test mode: capturing frames every 5 seconds.")
    utils.log(f"Initial window region: {emulator.window_region}")
    count = 0
    while count < 5:
        frame = emulator.capture_screen()
        utils.save_frame(frame, f"test_frame_{count}.png")
        utils.log(f"Captured test frame {count}")
        count += 1
        time.sleep(5)
 
 
======================== 
gamepad.py 
======================== 
import pyvjoy
import time
import config
import utils

class Gamepad:
    def __init__(self):
        """Initialize virtual gamepad using vJoy."""
        self.j = pyvjoy.VJoyDevice(1)  # Use vJoy Device 1

        # Updated Gamepad Mapping
        self.button_map = {
            "A": 1,
            "B": 2,
            "START": 8,
            "SELECT": 7,
            "UP": 3,
            "DOWN": 4,
            "LEFT": 5,
            "RIGHT": 6,
            "SCREENSHOT": 9  # New button mapped for mGBA screenshot
        }

        self.reset()

    def reset(self):
        """Reset all buttons on the virtual gamepad."""
        self.j.reset()
        self.j.reset_buttons()
        utils.log("vJoy gamepad reset to default state.")

    def press_button(self, action, is_manual=False):
        """Press a mapped button using vJoy.
        
        If is_manual=True, wait 5 seconds before pressing.
        """
        if action in self.button_map:
            button_id = self.button_map[action]

            if is_manual:
                utils.log(f"Waiting 5 seconds before pressing: {action}")
                time.sleep(5)

            utils.log(f"Pressing gamepad button: {action} (vJoy Button {button_id})")
            self.j.set_button(button_id, 1)
            time.sleep(0.2)  # Hold duration
            self.j.set_button(button_id, 0)  # Release button

        else:
            utils.log(f"Invalid action '{action}' sent to gamepad.")

if __name__ == "__main__":
    gp = Gamepad()
    print("Manual Gamepad Test Mode: Enter button names to simulate input.")
    while True:
        action = input("Enter button (A, B, START, SELECT, UP, DOWN, LEFT, RIGHT, SCREENSHOT) or 'exit': ").strip().upper()
        if action == "EXIT":
            break
        gp.press_button(action, is_manual=True)
 
 
======================== 
main.py 
======================== 
import time
import utils
import config
import torch
from emulator import Emulator
from vision import Vision
from decision import Decision

class PokemonTrainerAI:
    def __init__(self):
        # Set PyTorch to use deterministic algorithms for better performance
        if hasattr(torch, 'backends') and hasattr(torch.backends, 'cudnn'):
            torch.backends.cudnn.benchmark = True
            torch.backends.cudnn.deterministic = False
        
        # Initialize components
        self.emulator = Emulator()
        self.vision = Vision(self.emulator)
        self.decision = Decision(self.vision)

        self.action_count = 0
        self.game_completed = False
        self.failure_count = 0
        self.stuck_count = 0
        self.last_actions = []  # Track recent actions to detect stuck states
        self.last_action_time = time.time()
        
        # Track timing statistics for performance monitoring
        self.timing_stats = {
            "vision": [],
            "decision": [],
            "action": []
        }

    def is_stuck(self):
        """Check if we're stuck in the same game state repeating the same actions"""
        if len(self.last_actions) < 10:
            return False
            
        if len(set(self.last_actions[-10:])) == 1:
            self.stuck_count += 1
            utils.log(f"Detected possible stuck state - same action {self.last_actions[-1]} repeated 10 times")
            return True
            
        return False

    def perform_recovery_action(self):
        """Attempt to recover from stuck states with a sequence of actions"""
        utils.log("Performing recovery sequence...")
        recovery_sequence = ["B", "START", "B", "A", "DOWN", "DOWN", "A", "B"]
        
        for action in recovery_sequence:
            utils.log(f"Recovery action: {action}")
            self.emulator.press_button(action)
            time.sleep(0.5)  # Reduced wait time for faster recovery
            
        self.stuck_count = 0
        self.last_actions = []

    def log_performance_stats(self):
        """Log performance statistics periodically"""
        if self.action_count % 50 == 0:
            stats = {}
            for key, values in self.timing_stats.items():
                if values:
                    stats[key] = {
                        "avg": sum(values) / len(values),
                        "min": min(values),
                        "max": max(values),
                        "total": len(values)
                    }
            
            utils.log(f"Performance stats after {self.action_count} actions:")
            for key, metrics in stats.items():
                utils.log(f"  {key}: avg={metrics['avg']:.3f}s, min={metrics['min']:.3f}s, max={metrics['max']:.3f}s")
            
            # Reset stats after logging
            self.timing_stats = {k: [] for k in self.timing_stats.keys()}

    def run(self):
        utils.log("Starting Pokémon Blue AI training with optimized models...")
        
        utils.log("Pressing START button to begin game...")
        self.emulator.press_button("START")
        time.sleep(5)  # Reduced wait time
        
        while not self.game_completed:
            try:
                start_time = time.time()
                
                # Execute next action
                decision_start = time.time()
                action = self.decision.get_next_action()
                decision_time = time.time() - decision_start
                self.timing_stats["decision"].append(decision_time)
                
                # Press the button and wait 1 second for the game to update
                self.emulator.press_button(action)
                time.sleep(1)  # Wait for the game to reflect the action
                
                # Capture updated screenshot after waiting
                frame = self.emulator.capture_screen()
                utils.save_frame(frame, "post_action.png")  # Overwrite the same file
                
                # Get game state text from the updated frame
                vision_start = time.time()
                game_state_text = self.vision.get_game_state_text()
                vision_time = time.time() - vision_start
                self.timing_stats["vision"].append(vision_time)
                
                # Add action to history
                self.last_actions.append(action)
                if len(self.last_actions) > 20:
                    self.last_actions.pop(0)
                
                self.action_count += 1
                
                # Log action time and potential performance issues
                elapsed = time.time() - self.last_action_time
                self.last_action_time = time.time()
                
                if self.action_count % 10 == 0:
                    utils.log(f"Action {self.action_count}: {action} - Vision: {vision_time:.3f}s, Decision: {decision_time:.3f}s, Total: {elapsed:.3f}s")
                    self.log_performance_stats()
                
                # Check for stuck state and recovery
                if self.is_stuck() and self.stuck_count >= 3:
                    utils.log(f"Detected stuck state {self.stuck_count} times - attempting recovery")
                    self.perform_recovery_action()
                
                # Check for game completion
                if "Hall of Fame" in game_state_text:
                    utils.log(f"Game completed in {self.action_count} actions!")
                    self.game_completed = True
                
                # Dynamic polling interval based on game state
                if self.decision.current_state == "UNKNOWN":
                    time.sleep(config.POLLING_INTERVAL * 1.5)
                elif self.decision.current_state in ["TITLE_SCREEN", "DIALOGUE", "INTRO_SEQUENCE"]:
                    time.sleep(config.POLLING_INTERVAL * 0.7)  # Faster for simple states
                else:
                    time.sleep(config.POLLING_INTERVAL)
                    
            except Exception as e:
                self.failure_count += 1
                utils.log(f"Error during gameplay loop: {e}")
                if self.failure_count > 5:
                    utils.log("Too many consecutive failures. Restarting emulator...")
                    self.emulator.restart_emulator_if_closed()
                    self.failure_count = 0
                time.sleep(config.POLLING_INTERVAL * 2)

if __name__ == "__main__":
    # Try to free up memory before starting
    if torch.cuda.is_available():
        torch.cuda.empty_cache()
    
    PokemonTrainerAI().run() 
 
======================== 
memory_utils.py 
======================== 
"""
Utility functions for optimizing memory usage with PyTorch models.
This helps reduce VRAM consumption and allows models to run faster.
"""

import torch
import gc
import os
import psutil

def print_gpu_memory():
    """Print current GPU memory usage for monitoring."""
    if torch.cuda.is_available():
        for i in range(torch.cuda.device_count()):
            allocated = torch.cuda.memory_allocated(i) / 1024**2
            reserved = torch.cuda.memory_reserved(i) / 1024**2
            print(f"GPU Device {i}: {allocated:.2f} MB allocated, {reserved:.2f} MB reserved")
    else:
        print("No GPU available.")

def free_gpu_memory():
    """Free up unused GPU memory."""
    if torch.cuda.is_available():
        torch.cuda.empty_cache()
        gc.collect()
        print("Freed GPU memory.")
    else:
        print("No GPU available to free.")

def print_cpu_memory():
    """Print current CPU memory usage for this process."""
    process = psutil.Process(os.getpid())
    mem = process.memory_info().rss / 1024**2  # Convert bytes to MB
    print(f"CPU Memory usage: {mem:.2f} MB")

def free_cpu_memory():
    """Force garbage collection to free up CPU memory."""
    gc.collect()
    print("Forced garbage collection for CPU memory.")

if __name__ == "__main__":
    print("GPU Memory Info:")
    print_gpu_memory()
    print("\nCPU Memory Info:")
    print_cpu_memory()
    # Optionally free memory
    free_gpu_memory()
    free_cpu_memory()
 
 
======================== 
utils.py 
======================== 
import os
import cv2
import datetime
import config

def log(message):
    """Logs a message with a timestamp."""
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    log_message = f"[{timestamp}] {message}"
    print(log_message)
    log_file = os.path.join(config.LOG_DIR, "log.txt")
    with open(log_file, "a") as f:
        f.write(log_message + "\n")

def save_frame(frame, filename=None):
    """Saves a frame for debugging if enabled."""
    if config.SAVE_FRAMES:
        if filename is None:
            filename = f"frame_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
        filepath = os.path.join(config.FRAME_SAVE_DIR, filename)
        cv2.imwrite(filepath, frame)
        log(f"Saved frame: {filepath}")

def map_action_to_key(action):
    """Maps an action string to the emulator's keybinds."""
    return config.KEY_MAPPING.get(action.upper(), None)
 
 
======================== 
vision.py 
======================== 
import time
import utils
import config
import torch
from transformers import AutoModelForCausalLM
import cv2
import numpy as np
import os
from PIL import Image

class Vision:
    """
    Optimized Moondream-based vision class with enhanced game state detection capabilities.
    Uses brightness checks to distinguish between deep dark caves and walking areas,
    and leverages walkthrough-based context for improved environment consistency.
    """
    def __init__(self, emulator=None):
        self.emulator = emulator
        self.device = "cuda" if torch.cuda.is_available() else "cpu"

        # Load Moondream model with full float16 precision for compatibility
        self.model = AutoModelForCausalLM.from_pretrained(
            config.VISION_MODEL_PATH,
            revision="2025-01-09",
            trust_remote_code=True,
            device_map={"": self.device},
            torch_dtype=torch.float16
        )
        if torch.cuda.is_available() and config.TORCH_COMPILE:
            self.model = torch.compile(self.model)
        
        utils.log(f"Moondream model initialized on: {self.device} with full float16 precision")

        self.valid_buttons = ["UP", "DOWN", "LEFT", "RIGHT", "A", "B", "START", "SELECT"]

        self.base_prompt = """
Describe this Pokémon Blue game screen in detail. Focus on:
1. Game state (be specific: title screen, dialogue, battle type, menu, overworld, cave, dark cave, gym)
2. All visible text or menu options
3. Character and NPC positions
4. Environment details (indoors, outdoors, cave, water)
5. Battle information if present (Pokémon names, HP, moves)
6. Any obstacles or interactive elements (doors, signs, trees, boulders)

Be comprehensive but concise. Include environmental cues that indicate location type.
"""

        self.specialized_prompts = {
            "CAVE_DETECTION": """
Is the player in a cave environment? Look for:
- Dark/rocky surroundings
- Limited visibility (but not pitch black)
- Cave entrance/exit and open areas
- Rock formations and tunnels
Describe the cave features and any visible paths or items.
""",
            "DARK_CAVE_DETECTION": """
Is this a dark cave where Flash is needed? Look for:
- Very limited visibility (small area around the player)
- Mostly black or near-black surroundings
- Difficulty distinguishing paths or walls
Describe the limited visibility and any cues.
"""
        }

        self.consecutive_title_screens = 0
        self.frames_captured = 0
        self.last_frame_hash = None
        self.current_environment = "UNKNOWN"
        self.environment_confidence = 0
        self.environment_history = []
        self.max_history = 5

        # Save last confirmed cave state for continuity.
        self.last_cave_state = None

        # Walkthrough-based planned states (example subset extracted from the walkthrough)
        self.walkthrough_path = [
            "PALLET_TOWN", "ROUTE_1", "VIRIDIAN_CITY", "POKEMON_CENTER",
            "OAKS_LAB", "VIRIDIAN_FOREST", "MT_MOON", "PEWTER_CITY"
        ]

    def capture_screen(self):
        if not self.emulator:
            utils.log("WARNING: No emulator provided to Vision. Returning blank image.")
            return Image.new('RGB', (160, 144), color=(0, 0, 0))
        
        self.frames_captured += 1
        frame = self.emulator.capture_screen()
        
        if self.frames_captured % config.FRAME_LOGGING_FREQUENCY == 0:
            utils.save_frame(frame, f"frame_{self.frames_captured}.png")
            
        return Image.fromarray(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB))
    
    def _hash_image(self, image):
        # Simple hash function if needed for debugging.
        img_small = image.resize((32, 32)).convert('L')
        img_array = np.array(img_small)
        return hash(img_array.tobytes())
    
    def get_average_brightness(self, image):
        grayscale = image.convert("L")
        np_image = np.array(grayscale)
        return np.mean(np_image)
    
    def detect_environment(self, description):
        description_upper = description.upper()
        if any(term in description_upper for term in ["DARK CAVE", "CAN'T SEE", "LIMITED VISIBILITY", "FLASH NEEDED"]):
            return "DARK_CAVE"
        if any(term in description_upper for term in ["MT MOON", "MT. MOON"]):
            return "MT_MOON"
        if "ROCK TUNNEL" in description_upper:
            return "ROCK_TUNNEL"
        if "VICTORY ROAD" in description_upper:
            return "VICTORY_ROAD"
        if any(term in description_upper for term in ["CAVE", "TUNNEL", "UNDERGROUND", "ROCKY"]):
            return "CAVE"
        if any(term in description_upper for term in ["POKEMON CENTER", "POKÉMON CENTER", "NURSE JOY", "HEALING"]):
            return "POKEMON_CENTER"
        if any(term in description_upper for term in ["MART", "SHOP", "STORE", "CLERK", "BUY"]):
            return "POKEMON_MART"
        if "GYM" in description_upper:
            return "GYM"
        if any(term in description_upper for term in ["HOUSE", "BUILDING", "INSIDE", "INTERIOR", "INDOOR"]):
            return "BUILDING"
        if "GYM LEADER" in description_upper and "BATTLE" in description_upper:
            return "GYM_LEADER_BATTLE"
        if "TRAINER" in description_upper and "BATTLE" in description_upper:
            return "TRAINER_BATTLE"
        if "WILD" in description_upper and "BATTLE" in description_upper:
            return "WILD_BATTLE"
        if any(term in description_upper for term in ["BATTLE", "FIGHT", "POKEMON VS", "POKÉMON VS"]):
            return "BATTLE"
        if any(term in description_upper for term in ["TITLE SCREEN", "BLUE VERSION", "PRESS START"]):
            return "TITLE_SCREEN"
        if any(term in description_upper for term in ["TEXT BOX", "DIALOGUE", "TALKING", "MESSAGE"]):
            return "DIALOGUE"
        if any(term in description_upper for term in ["MENU", "OPTIONS", "ITEMS", "POKEMON LIST", "POKÉMON LIST"]):
            return "MENU"
        return "OVERWORLD"
    
    def update_environment_tracking(self, detected_env):
        self.environment_history.append(detected_env)
        if len(self.environment_history) > self.max_history:
            self.environment_history.pop(0)
        env_counts = {}
        for env in self.environment_history:
            env_counts[env] = env_counts.get(env, 0) + 1
        most_common_env = max(env_counts.items(), key=lambda x: x[1])
        confidence = most_common_env[1] / len(self.environment_history)
        if confidence >= 0.6:
            prev_env = self.current_environment
            self.current_environment = most_common_env[0]
            self.environment_confidence = confidence
            if self.current_environment in ["CAVE", "DARK_CAVE"]:
                self.last_cave_state = self.current_environment
            if prev_env != self.current_environment:
                utils.log(f"Environment change: {prev_env} -> {self.current_environment} (confidence: {confidence:.2f})")
        return self.current_environment
    
    def get_game_state_text(self):
        image = self.capture_screen()
        # Always load the current screenshot—do not use cached data.
        brightness = self.get_average_brightness(image)
        DARK_THRESHOLD = 40    # Below this value, consider the screen dark.
        BRIGHT_THRESHOLD = 60  # Above this, the screen is clearly bright.
        
        if brightness < DARK_THRESHOLD:
            utils.log(f"Dark screen detected (brightness: {brightness:.1f}). Forcing DARK_CAVE state.")
            caption = "Dark cave environment with very limited visibility. Flash needed."
            detected_env = "DARK_CAVE"
            self.update_environment_tracking(detected_env)
            self.last_cave_state = detected_env
            return caption
        
        if brightness > BRIGHT_THRESHOLD and self.last_cave_state in ["DARK_CAVE", "CAVE"]:
            utils.log(f"Bright screen detected (brightness: {brightness:.1f}). Interpreting as walking through a cave.")
            self.last_cave_state = "CAVE"
        
        # Always generate a fresh description from the current image.
        prompt_to_use = self.base_prompt
        if any(env in ["CAVE", "MT_MOON", "ROCK_TUNNEL", "VICTORY ROAD"] for env in self.environment_history[-2:]):
            prompt_to_use = self.specialized_prompts["CAVE_DETECTION"]
            utils.log("Using specialized cave detection prompt")
        elif "DARK_CAVE" in self.environment_history[-2:]:
            prompt_to_use = self.specialized_prompts["DARK_CAVE_DETECTION"]
            utils.log("Using specialized dark cave detection prompt")
        
        with torch.inference_mode():
            caption = self.model.query(
                image,
                prompt_to_use,
            )["answer"]
        
        utils.log(f"Moondream Screen Description: {caption}")
        
        detected_env = self.detect_environment(caption)
        if detected_env == "OVERWORLD" and self.last_cave_state in ["CAVE", "DARK_CAVE"]:
            utils.log("Forcing cave state from previous context due to walkthrough continuity.")
            detected_env = self.last_cave_state
            caption = f"Continuing {detected_env} exploration."
        
        self.update_environment_tracking(detected_env)
        if ("title screen" in caption.lower() or "blue version" in caption.lower()) and \
           ("professor" not in caption.lower() and "oak" not in caption.lower()):
            self.consecutive_title_screens += 1
            utils.log(f"Title screen detection count: {self.consecutive_title_screens}")
        else:
            self.consecutive_title_screens = 0
            
        return caption

    def get_context_aware_prompt(self, task_instruction=None):
        base_prefix = "You are playing Pokémon Blue. "
        base_suffix = "\nReply with ONLY one button: UP, DOWN, LEFT, RIGHT, A, B, START, SELECT"
        env_instructions = {
            "DARK_CAVE": "You're in a dark cave with very limited visibility. Consider using Flash if available. ",
            "CAVE": "You're exploring a cave with visible details and open areas. Watch for wild Pokémon and items. ",
            "MT_MOON": "You're in Mt. Moon. Watch for Zubat encounters and fossil researchers. ",
            "ROCK_TUNNEL": "You're in Rock Tunnel. This cave is complex with many trainers. ",
            "VICTORY_ROAD": "You're in Victory Road. This is a challenging cave with strength puzzles. ",
            "POKEMON_CENTER": "You're in a Pokémon Center. Talk to Nurse Joy to heal your Pokémon. ",
            "POKEMON_MART": "You're in a Pokémon Mart. You can buy items from the clerk. ",
            "GYM": "You're in a Pokémon Gym. Navigate to the Gym Leader while defeating trainers. ",
            "WILD_BATTLE": "You're in a wild Pokémon battle. Choose fight for moves, or other options like Run. ",
            "TRAINER_BATTLE": "You're in a trainer battle. Choose your moves wisely. ",
            "GYM_LEADER_BATTLE": "You're battling a Gym Leader! This is an important battle for a badge. ",
            "TITLE_SCREEN": "You're at the title screen. ",
            "DIALOGUE": "You're in a dialogue or text screen. ",
            "MENU": "You're navigating a menu. Use directional buttons to navigate and A to select. ",
            "OVERWORLD": "You're exploring the overworld. "
        }
        
        env_instruction = env_instructions.get(self.current_environment, "Choose a button based on what you see. ")
        walkthrough_hint = ""
        if self.walkthrough_path:
            walkthrough_hint = "Remember your planned path from the walkthrough."
        if task_instruction:
            prompt = f"{base_prefix}{walkthrough_hint}\nChoose a button based on this instruction:\n{task_instruction}{base_suffix}"
        else:
            prompt = f"{base_prefix}{env_instruction} {walkthrough_hint}{base_suffix}"
            
        return prompt

    def get_next_action(self, task_instruction=None):
        if self.consecutive_title_screens >= 2:
            utils.log("Multiple title screens detected. Forcing START button.")
            return "START"
        
        # Always use a fresh screenshot.
        prompt = self.get_context_aware_prompt(task_instruction)
        utils.log(f"Using prompt: {prompt}")
        
        with torch.inference_mode():
            response = self.model.query(
                self.capture_screen(),
                prompt,
            )["answer"]
        
        utils.log(f"Moondream raw decision: {response}")
        action = response.strip().upper()
        
        if ("TITLE SCREEN" in action or "BLUE VERSION" in action) and \
           ("PROFESSOR" not in action and "OAK" not in action):
            utils.log("Title screen text detected in response, overriding to START")
            return "START"
        
        for button in self.valid_buttons:
            if button in action:
                utils.log(f"Extracted button '{button}' from '{action}'")
                return button
                
        if self.current_environment == "DARK_CAVE":
            utils.log("In dark cave with no clear action. Defaulting to START to access Flash.")
            return "START"
        
        if self.current_environment == "DIALOGUE":
            utils.log("In dialogue with no clear action. Defaulting to A.")
            return "A"
        
        utils.log(f"No valid button in '{action}'. Defaulting to RETRYING.")
        return self.get_next_action(task_instruction)
 
 
