======================== 
config.py 
======================== 
import os


# === Vision Model Settings ===
VISION_MODEL_PATH = "vikhyatk/moondream2"

# === ROM & Emulator Settings ===
ROM_PATH = "roms/pokemon_blue.gb"
POLLING_INTERVAL = 1  # Default polling interval in seconds
EMULATOR_PATH = "C:\\Program Files\\mGBA\\mGBA.exe"

# Screenshot location (same as ROM directory)
SCREENSHOT_PATH = os.path.join(os.path.dirname(ROM_PATH), "screenshot.png")

# === Debugging & Logging ===
LOG_DIR = os.path.join(os.getcwd(), "logs")
os.makedirs(LOG_DIR, exist_ok=True)  # Ensure log directory exists
SAVE_FRAMES = True
FRAME_SAVE_DIR = os.path.join(os.getcwd(), "logs", "frames")
os.makedirs(FRAME_SAVE_DIR, exist_ok=True)

# === Input Settings ===
KEY_MAPPING = {
    "UP": "up",
    "DOWN": "down",
    "LEFT": "left",
    "RIGHT": "right",
    "A": "z",      # Adjust based on emulator key mapping
    "B": "x",
    "START": "enter",
    "SELECT": "backspace",
    "SCREENSHOT": "F12"  # New key for triggering mGBA screenshot
}
 
 
======================== 
decision.py 
======================== 
import utils

class Decision:
    """
    A simple class that delegates to Vision for the next action.
    This keeps the 'decision' logic in a separate file, but
    all the real work is done by Moondream in vision.py.
    """
    def __init__(self, vision):
        self.vision = vision

    def get_next_action(self):
        # Just call vision.get_next_action()
        action = self.vision.get_next_action()
        utils.log(f"Decision: {action}")
        return action
 
 
======================== 
emulator.py 
======================== 
import pyautogui
import pygetwindow as gw
import time
import cv2
import numpy as np
import config
import utils
import subprocess
import psutil
import win32gui
import win32con
import os
from gamepad import Gamepad

class Emulator:
    def __init__(self):
        self.polling_interval = config.POLLING_INTERVAL
        self.window_region = None
        self.last_keypress_time = 0
        self.process = None
        self.gamepad = Gamepad()
        self.window_title = "mGBA"

        self.attach_or_launch_emulator()
        success = self.update_window_region()
        if not success:
            utils.log("WARNING: Failed to detect mGBA window. Capturing may not work correctly.")

    def is_emulator_running(self):
        if self.process is None:
            return False
        return self.process.poll() is None if hasattr(self.process, 'poll') else self.process.is_running()

    def find_existing_emulator(self):
        for proc in psutil.process_iter(attrs=["pid", "name"]):
            if "mgba" in proc.info["name"].lower():
                utils.log(f"Attached to existing mGBA process (PID {proc.info['pid']})")
                return psutil.Process(proc.info["pid"])
        return None

    def update_window_region(self):
        """
        Detect mGBA window, crop out top menu bar, etc.
        """
        try:
            windows = gw.getWindowsWithTitle(self.window_title)
            if windows:
                window = windows[0]
                if window.isMinimized:
                    win32gui.ShowWindow(window._hWnd, win32con.SW_RESTORE)
                    time.sleep(0.5)
                
                x, y, width, height = window.left, window.top, window.width, window.height

                # Approx offsets
                top_menu_height = 120
                bottom_border = 110
                side_border = 95

                content_x = x + side_border
                content_y = y + top_menu_height
                content_width = width - (side_border * 2)
                content_height = height - top_menu_height - bottom_border

                self.window_region = (content_x, content_y, content_width, content_height)
                utils.log(f"Updated mGBA window region to: {self.window_region}")

                self.debug_capture()
                return True
            else:
                utils.log("No mGBA window found to update region.")
                return False
        except Exception as e:
            utils.log(f"Error updating window region: {e}")
            return False

    def debug_capture(self):
        if self.window_region is None:
            utils.log("No window region to capture.")
            return
        try:
            screenshot = pyautogui.screenshot(region=self.window_region)
            debug_path = os.path.join(config.FRAME_SAVE_DIR, "window_debug.png")
            screenshot.save(debug_path)
            utils.log(f"Saved debug capture: {debug_path}")
        except Exception as e:
            utils.log(f"Failed to save debug capture: {e}")

    def bring_emulator_to_front(self):
        try:
            windows = gw.getWindowsWithTitle(self.window_title)
            if windows:
                window = windows[0]
                win32gui.ShowWindow(window._hWnd, win32con.SW_RESTORE)
                win32gui.SetForegroundWindow(window._hWnd)
                utils.log("Brought mGBA window to the front.")
                self.update_window_region()
            else:
                utils.log("No mGBA window found to bring to front.")
        except Exception as e:
            utils.log(f"Failed to bring mGBA to front: {e}")

    def attach_or_launch_emulator(self):
        existing_process = self.find_existing_emulator()
        if existing_process:
            self.process = existing_process
        else:
            self.launch_emulator()

    def launch_emulator(self):
        if not self.is_emulator_running():
            utils.log("Launching mGBA emulator...")
            self.process = subprocess.Popen([config.EMULATOR_PATH, config.ROM_PATH])
            time.sleep(3)
            self.bring_emulator_to_front()

    def restart_emulator_if_closed(self):
        if self.process is None or (hasattr(self.process, 'is_running') and not self.process.is_running()):
            utils.log("Emulator closed unexpectedly. Restarting...")
            self.launch_emulator()

    def capture_screen(self):
        self.restart_emulator_if_closed()
        self.bring_emulator_to_front()

        if not self.update_window_region():
            utils.log("ERROR: Failed to update window region for capture.")
            if self.window_region:
                black_frame = np.zeros((self.window_region[3], self.window_region[2], 3), dtype=np.uint8)
                return black_frame
            else:
                return np.zeros((320, 288, 3), dtype=np.uint8)  # default fallback

        screenshot = pyautogui.screenshot(region=self.window_region)
        return cv2.cvtColor(np.array(screenshot), cv2.COLOR_RGB2BGR)

    def press_key(self, key):
        current_time = time.time()
        if current_time - self.last_keypress_time < 0.3:
            return
        self.restart_emulator_if_closed()
        self.bring_emulator_to_front()
        pyautogui.press(key)
        self.last_keypress_time = current_time
        utils.log(f"Pressed key: {key}")

    def press_button(self, action):
        """
        Use the virtual gamepad to press a button.
        """
        self.restart_emulator_if_closed()
        self.bring_emulator_to_front()
        self.gamepad.press_button(action)
        utils.log(f"Pressed gamepad button: {action}")

    def trigger_screenshot(self):
        utils.log("Triggering mGBA screenshot via gamepad...")
        self.gamepad.press_button("SCREENSHOT")

if __name__ == "__main__":
    emulator = Emulator()
    utils.log("Emulator test mode: capturing frames every 5 seconds.")
    utils.log(f"Initial window region: {emulator.window_region}")
    count = 0
    while count < 5:
        frame = emulator.capture_screen()
        utils.save_frame(frame, f"test_frame_{count}.png")
        utils.log(f"Captured test frame {count}")
        count += 1
        time.sleep(5)
 
 
======================== 
gamepad.py 
======================== 
import pyvjoy
import time
import config
import utils

class Gamepad:
    def __init__(self):
        """Initialize virtual gamepad using vJoy."""
        self.j = pyvjoy.VJoyDevice(1)  # Use vJoy Device 1

        # Updated Gamepad Mapping
        self.button_map = {
            "A": 1,
            "B": 2,
            "START": 8,
            "SELECT": 7,
            "UP": 3,
            "DOWN": 4,
            "LEFT": 5,
            "RIGHT": 6,
            "SCREENSHOT": 9  # New button mapped for mGBA screenshot
        }

        self.reset()

    def reset(self):
        """Reset all buttons on the virtual gamepad."""
        self.j.reset()
        self.j.reset_buttons()
        utils.log("vJoy gamepad reset to default state.")

    def press_button(self, action, is_manual=False):
        """Press a mapped button using vJoy.
        
        If is_manual=True, wait 5 seconds before pressing.
        """
        if action in self.button_map:
            button_id = self.button_map[action]

            if is_manual:
                utils.log(f"Waiting 5 seconds before pressing: {action}")
                time.sleep(5)

            utils.log(f"Pressing gamepad button: {action} (vJoy Button {button_id})")
            self.j.set_button(button_id, 1)
            time.sleep(0.2)  # Hold duration
            self.j.set_button(button_id, 0)  # Release button

        else:
            utils.log(f"Invalid action '{action}' sent to gamepad.")

if __name__ == "__main__":
    gp = Gamepad()
    print("Manual Gamepad Test Mode: Enter button names to simulate input.")
    while True:
        action = input("Enter button (A, B, START, SELECT, UP, DOWN, LEFT, RIGHT, SCREENSHOT) or 'exit': ").strip().upper()
        if action == "EXIT":
            break
        gp.press_button(action, is_manual=True)
 
 
======================== 
main.py 
======================== 
import time
import utils
import config
from emulator import Emulator
from vision import Vision
from decision import Decision

class PokemonTrainerAI:
    def __init__(self):
        self.emulator = Emulator()         # For capturing screen & gamepad button presses
        self.vision = Vision(self.emulator)  # Moondream-based vision+decision
        self.decision = Decision(self.vision)

        self.action_count = 0
        self.game_completed = False

    def run(self):
        utils.log("Starting Pokémon Blue AI training (All Moondream)...")
        while not self.game_completed:
            # Get next action from Decision (which calls Vision -> Moondream)
            action = self.decision.get_next_action()
            # Use the gamepad to press the corresponding button
            self.emulator.press_button(action)
            self.action_count += 1

            # Optional: Check if we see "Hall of Fame" in the screen text
            game_state_text = self.vision.get_game_state_text()
            if "Hall of Fame" in game_state_text:
                utils.log(f"Game completed in {self.action_count} actions!")
                self.game_completed = True

            time.sleep(config.POLLING_INTERVAL)

if __name__ == "__main__":
    PokemonTrainerAI().run()
 
 
======================== 
utils.py 
======================== 
import os
import cv2
import datetime
import config

def log(message):
    """Logs a message with a timestamp."""
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    log_message = f"[{timestamp}] {message}"
    print(log_message)
    log_file = os.path.join(config.LOG_DIR, "log.txt")
    with open(log_file, "a") as f:
        f.write(log_message + "\n")

def save_frame(frame, filename=None):
    """Saves a frame for debugging if enabled."""
    if config.SAVE_FRAMES:
        if filename is None:
            filename = f"frame_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
        filepath = os.path.join(config.FRAME_SAVE_DIR, filename)
        cv2.imwrite(filepath, frame)
        log(f"Saved frame: {filepath}")

def map_action_to_key(action):
    """Maps an action string to the emulator's keybinds."""
    return config.KEY_MAPPING.get(action.upper(), None)
 
 
======================== 
vision.py 
======================== 
import torch
from transformers import AutoModelForCausalLM, AutoProcessor
import config
import utils
import cv2
import numpy as np
import os
from PIL import Image

class Vision:
    """
    Moondream-based vision & decision. One class that:
      1. Captures the screen from the emulator.
      2. Uses Moondream to pick the next button to press.
    """
    def __init__(self, emulator=None):
        self.emulator = emulator
        self.device = "cuda" if torch.cuda.is_available() else "cpu"

        # Load Moondream
        self.processor = AutoProcessor.from_pretrained(
            config.VISION_MODEL_PATH,
            trust_remote_code=True
        )
        self.model = AutoModelForCausalLM.from_pretrained(
            config.VISION_MODEL_PATH,
            revision="2025-01-09",
            trust_remote_code=True,
            device_map={"": self.device}
        )
        utils.log(f"Moondream model initialized on: {self.device}")

        # Valid buttons
        self.valid_buttons = ["UP", "DOWN", "LEFT", "RIGHT", "A", "B", "START", "SELECT"]

    def capture_screen(self):
        """
        Capture the emulator screen as a PIL image.
        """
        if not self.emulator:
            utils.log("WARNING: No emulator provided to Vision. Returning blank image.")
            return Image.new('RGB', (160, 144), color=(0, 0, 0))

        frame = self.emulator.capture_screen()
        return Image.fromarray(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB))

    def get_game_state_text(self):
        """
        Optional: Return a descriptive text about the current screen, for debugging or logs.
        """
        image = self.capture_screen()
        encoded = self.model.encode_image(image)

        # Basic caption from Moondream
        caption = self.model.caption(encoded, length="normal")["caption"]
        utils.log(f"Moondream Screen Caption: {caption}")
        return caption

    def get_next_action(self):
        """
        Use Moondream to directly choose the next button press from [UP, DOWN, LEFT, RIGHT, A, B, START, SELECT].
        """
        while True:
            image = self.capture_screen()
            encoded = self.model.encode_image(image)

            # Context-aware Moondream Prompt
            moondream_prompt = """
            You are playing Pokémon Blue on a Game Boy. Your goal is to complete the game as efficiently as possible by selecting the best button press for the current situation.

            Here are the possible controls you can choose from:
            - UP, DOWN, LEFT, RIGHT → Move the player character or navigate menus.
            - A → Confirm selections, talk to NPCs, progress dialogue.
            - B → Cancel selections, close menus, sometimes speeds up text.
            - START → Open the main menu (only use when necessary).
            - SELECT → Rarely used, but opens secondary menu in certain cases.

            Decision Strategy:
            1. If on the title screen and the text includes "Blue Version" press START.
            2. If there is text on screen determine an action, A reads the text and moves on unless in menus.
            3. If navigating menus, choose UP/DOWN to move and A to confirm selections.
            4. If in battle, select the appropriate action:
               - A to confirm an attack or select a move.
               - UP/DOWN to navigate between move options.
               - LEFT/RIGHT if switching Pokémon or selecting an item.
            5. If walking around, use UP/DOWN/LEFT/RIGHT to navigate the map.
            6. If reading dialogue, use A to continue. If text is slow, B can sometimes speed it up.

            IMPORTANT:
            - Return ONLY a single action (UP, DOWN, LEFT, RIGHT, A, B, START, SELECT) with no extra text.
            - Do not press START or A repeatedly unless it is required.
            - Ensure your decision matches the context of the screen.
            """
            response = self.model.query(encoded, moondream_prompt)["answer"]
            utils.log(f"Moondream Raw Decision: {response}")

            # Clean up the response, uppercase it
            action = response.strip().upper()

            # If the action is valid, return it. Otherwise, retry.
            if action in self.valid_buttons:
                return action
            else:
                utils.log(f"Invalid Moondream action '{action}'. Retrying...") 
 
