======================== 
config.py 
======================== 
import os

# === Vision Model Settings ===
VISION_MODEL_PATH = "vikhyatk/moondream2"

# === Memory Optimization Settings ===
# Enable memory optimizations (8-bit quantization and offloading)
USE_8BIT_QUANTIZATION = True
USE_OFFLOADING = True

# === ROM & Emulator Settings ===
ROM_PATH = "roms/pokemon_blue.gb"
POLLING_INTERVAL = 0.8  # Reduced polling interval for faster gameplay
EMULATOR_PATH = "C:\\Program Files\\mGBA\\mGBA.exe"

# Screenshot location (same as ROM directory)
SCREENSHOT_PATH = os.path.join(os.path.dirname(ROM_PATH), "screenshot.png")

# === Debugging & Logging ===
LOG_DIR = os.path.join(os.getcwd(), "logs")
os.makedirs(LOG_DIR, exist_ok=True)  # Ensure log directory exists
SAVE_FRAMES = True
FRAME_SAVE_DIR = os.path.join(os.getcwd(), "logs", "frames")
os.makedirs(FRAME_SAVE_DIR, exist_ok=True)

# Reduce frame logging frequency to improve performance
FRAME_LOGGING_FREQUENCY = 20  # Save only every Nth frame

# === Cache Settings ===
# Enhanced caching to reduce model calls
VISION_CACHE_SIZE = 10
DECISION_CACHE_SIZE = 20
ENABLE_SIMILARITY_CACHE = True  # Enable fuzzy matching for cache hits

# === Input Settings ===
KEY_MAPPING = {
    "UP": "up",
    "DOWN": "down",
    "LEFT": "left",
    "RIGHT": "right",
    "A": "z",      # Adjust based on emulator key mapping
    "B": "x",
    "START": "enter",
    "SELECT": "backspace",
    "SCREENSHOT": "F12"  # New key for triggering mGBA screenshot
}

# === Performance Settings ===
# Performance optimization flags
TORCH_COMPILE = True      # Use torch.compile for models if available
HALF_PRECISION = True     # Use FP16 precision
LOW_CPU_USAGE = True      # Enable low CPU memory usage 
 
======================== 
decision.py 
======================== 
import torch
from transformers import AutoModelForCausalLM, AutoTokenizer, StoppingCriteria, StoppingCriteriaList, BitsAndBytesConfig
import utils
import config

class StopOnTokens(StoppingCriteria):
    def __init__(self, stop_token_ids):
        self.stop_token_ids = stop_token_ids
    
    def __call__(self, input_ids, scores, **kwargs):
        return any(input_ids[0][-1] == stop_id for stop_id in self.stop_token_ids)

class Decision:
    """
    Decision layer that leverages Llama-3.2-3B to generate concise task instructions
    from the game state and then delegates to Moondream (via Vision) to determine the
    next button press.
    """
    def __init__(self, vision, device=None):
        self.vision = vision
        self.device = device or ("cuda" if torch.cuda.is_available() else "cpu")
        self.llama_model_name = "meta-llama/Llama-3.2-3B"
        
        # Initialize Llama tokenizer
        self.tokenizer = AutoTokenizer.from_pretrained(self.llama_model_name)
        
        # Use BitsAndBytesConfig for proper 8-bit quantization settings
        quantization_config = BitsAndBytesConfig(
            load_in_8bit=True,
            llm_int8_enable_fp32_cpu_offload=False  # Ensure entire model stays in VRAM
        )
        
        # Load Llama model with 8-bit quantization and float16 precision
        self.llama_model = AutoModelForCausalLM.from_pretrained(
            self.llama_model_name,
            device_map="cuda",  # Force all modules on GPU
            quantization_config=quantization_config,
            torch_dtype=torch.float16,
            low_cpu_mem_usage=True
        )
        
        # Optional: Compile the model for faster inference (if using CUDA)
        if torch.cuda.is_available() and config.TORCH_COMPILE:
            self.llama_model = torch.compile(self.llama_model)
        
        # Stop tokens for controlled generation
        stop_words = [".", "\n"]
        stop_token_ids = [self.tokenizer.encode(word, add_special_tokens=False)[-1] for word in stop_words]
        self.stopping_criteria = StoppingCriteriaList([StopOnTokens(stop_token_ids)])
        
        utils.log(f"Llama model initialized on: {self.device} with 8-bit quantization (no CPU offload) and float16 precision")
        
        # Precompile prompts for faster generation
        self.prompt_templates = self._create_prompt_templates()
        
        # Track the current game state
        self.current_state = "UNKNOWN"
        self.previous_states = []
        self.state_transitions = 0
        
        # Improved cache for recently seen game states
        self.instruction_cache = {}
        self.cache_size = 20  

        # Direct action mapping for common states
        self.common_state_actions = {
            "TITLE_SCREEN": "START",
            "DIALOGUE": "A",
            "INTRO_SEQUENCE": "A",
            "ITEM_FOUND": "A",
            "HEALING": "A",
            "EVOLUTION": "A"
        }

    def _create_prompt_templates(self):
        """Create optimized prompt templates for Llama"""
        return {
            # General game states
            "TITLE_SCREEN": "You're at the Pokémon Blue title screen. Respond with: 'Press START button to begin the game.'",
            "INTRO_SEQUENCE": "You're in Professor Oak's introduction. Respond with: 'Press A button to continue dialogue.'",
            "DIALOGUE": "You're in a dialogue screen. Respond with: 'Press A button to continue dialogue.'",
            "MENU": "You're navigating a menu. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Press A', 'Press B'.",
            "OVERWORLD": "You're exploring the overworld. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Move LEFT', 'Move RIGHT', 'Press A'.",
            
            # Battle states with specificity
            "BATTLE": "You're in a Pokémon battle. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Move LEFT', 'Move RIGHT', 'Press A', 'Press B'.",
            "WILD_BATTLE": "You're in a wild Pokémon battle. Choose 'FIGHT' for moves, or other options. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Move LEFT', 'Move RIGHT', 'Press A', 'Press B'.",
            "TRAINER_BATTLE": "You're in a trainer battle. Choose your moves wisely. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Move LEFT', 'Move RIGHT', 'Press A', 'Press B'.",
            "GYM_LEADER_BATTLE": "You're battling a Gym Leader. This is an important battle for a badge. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Move LEFT', 'Move RIGHT', 'Press A', 'Press B'.",
            
            # Cave-specific templates
            "CAVE": "You're exploring a cave in Pokémon Blue. Watch for wild Pokémon encounters and look for items. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Move LEFT', 'Move RIGHT', 'Press A', 'Press START' (to access menu).",
            "DARK_CAVE": "You're in a dark cave without Flash. You can only see a small area around your character. Navigate carefully or use Flash. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Move LEFT', 'Move RIGHT', 'Press START' (to use Flash if available).",
            "MT_MOON": "You're in Mt. Moon. Watch for Zubat encounters and look for items and fossil researchers. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Move LEFT', 'Move RIGHT', 'Press A', 'Press START'.",
            "ROCK_TUNNEL": "You're in Rock Tunnel. This area is complex with many trainers. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Move LEFT', 'Move RIGHT', 'Press A', 'Press START'.",
            "VICTORY_ROAD": "You're in Victory Road. This is a challenging cave with strength puzzles and strong trainers. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Move LEFT', 'Move RIGHT', 'Press A', 'Press START'.",
            
            # Location-specific templates
            "BUILDING": "You're inside a building. Look for NPCs to talk to or items. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Move LEFT', 'Move RIGHT', 'Press A'.",
            "POKEMON_CENTER": "You're in a Pokémon Center. Talk to Nurse Joy to heal or use the PC. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Move LEFT', 'Move RIGHT', 'Press A'.",
            "POKEMON_MART": "You're in a Pokémon Mart. Talk to the clerk to buy items. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Move LEFT', 'Move RIGHT', 'Press A'.",
            "GYM": "You're in a Pokémon Gym. Navigate to the Gym Leader while defeating trainers. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Move LEFT', 'Move RIGHT', 'Press A'.",
            
            # Special interaction templates
            "ITEM_FOUND": "You've found an item. Respond with: 'Press A to pick up the item.'",
            "HEALING": "Your Pokémon are being healed. Respond with: 'Press A to continue.'",
            "EVOLUTION": "Your Pokémon is evolving! Respond with: 'Press A to continue evolution' or 'Press B to cancel evolution'.",
            "FISHING": "You're using a fishing rod. Wait for a bite. Respond with: 'Press A when there's a bite.'",
            
            # Menu-specific templates
            "POKEMON_MENU": "You're in the Pokémon menu. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Press A to select', 'Press B to exit'.",
            "ITEM_MENU": "You're in the Item menu. Respond with exactly one of: 'Move UP', 'Move DOWN', 'Press A to use item', 'Press B to exit'.",
            "SAVE_MENU": "You're at the save prompt. Respond with: 'Press A to save' or 'Press B to cancel'.",
            
            # Puzzle-specific templates
            "STRENGTH_PUZZLE": "You're at a strength puzzle. You need to push boulders. Respond with: 'Press A to use Strength' or 'Move in the direction to push boulder'.",
            "CUT_OBSTACLE": "There's a small tree blocking your path. Respond with: 'Press A to use Cut' if facing the tree.",
            "SURF_WATER": "You're at a body of water. Respond with: 'Press A to use Surf' if facing the water."
        }

    def detect_game_state(self, game_state_text):
        """
        Analyzes the game state description to determine the player's situation.
        """
        game_state_upper = game_state_text.upper()

        # More precise detection logic with priority order
        if ("PROFESSOR" in game_state_upper or "OAK" in game_state_upper) and "INTRO" in game_state_upper:
            return "INTRO_SEQUENCE"
        if "BLUE VERSION" in game_state_upper or "TITLE SCREEN" in game_state_upper:
            return "TITLE_SCREEN"
            
        # Battle detection with specificity
        if "GYM LEADER" in game_state_upper and "BATTLE" in game_state_upper:
            return "GYM_LEADER_BATTLE"
        if "TRAINER" in game_state_upper and "BATTLE" in game_state_upper:
            return "TRAINER_BATTLE"
        if "WILD" in game_state_upper and "BATTLE" in game_state_upper:
            return "WILD_BATTLE"
        if "BATTLE" in game_state_upper or "FIGHT" in game_state_upper:
            return "BATTLE"
            
        # Cave detection with specificity
        if ("DARK" in game_state_upper or "CAN'T SEE" in game_state_upper) and ("CAVE" in game_state_upper or "TUNNEL" in game_state_upper):
            return "DARK_CAVE"
        if "MT MOON" in game_state_upper or "MT. MOON" in game_state_upper:
            return "MT_MOON"
        if "ROCK TUNNEL" in game_state_upper:
            return "ROCK_TUNNEL"
        if "VICTORY ROAD" in game_state_upper:
            return "VICTORY_ROAD"
        if "CAVE" in game_state_upper:
            return "CAVE"
            
        # Building detection
        if "POKEMON CENTER" in game_state_upper or "POKÉMON CENTER" in game_state_upper:
            return "POKEMON_CENTER"
        if "MART" in game_state_upper or "SHOP" in game_state_upper or "STORE" in game_state_upper:
            return "POKEMON_MART"
        if "GYM" in game_state_upper:
            return "GYM"
        if "BUILDING" in game_state_upper or "HOUSE" in game_state_upper or "INDOOR" in game_state_upper:
            return "BUILDING"
            
        # Special interactions
        if "FOUND" in game_state_upper and "ITEM" in game_state_upper:
            return "ITEM_FOUND"
        if "HEALING" in game_state_upper or "NURSE JOY" in game_state_upper:
            return "HEALING"
        if "EVOLVING" in game_state_upper or "EVOLUTION" in game_state_upper:
            return "EVOLUTION"
        if "FISHING" in game_state_upper or "FISHING ROD" in game_state_upper:
            return "FISHING"
            
        # Menu detection
        if "POKEMON" in game_state_upper and "MENU" in game_state_upper:
            return "POKEMON_MENU"
        if "ITEM" in game_state_upper and "MENU" in game_state_upper:
            return "ITEM_MENU"
        if "SAVE" in game_state_upper:
            return "SAVE_MENU"
        if "MENU" in game_state_upper or "OPTION" in game_state_upper:
            return "MENU"
            
        # Puzzle detection
        if "BOULDER" in game_state_upper and "STRENGTH" in game_state_upper:
            return "STRENGTH_PUZZLE"
        if "TREE" in game_state_upper and "CUT" in game_state_upper:
            return "CUT_OBSTACLE"
        if ("WATER" in game_state_upper or "LAKE" in game_state_upper or "OCEAN" in game_state_upper) and "SURF" in game_state_upper:
            return "SURF_WATER"
            
        # Text/dialogue detection
        if "TEXT" in game_state_upper or "DIALOGUE" in game_state_upper:
            return "DIALOGUE"
        
        # Default to overworld if no specific state is detected
        return "OVERWORLD"

    def get_llama_instruction(self, game_state):
        """
        Uses Llama-3.2-3B to generate a concise instruction based on the current game state.
        """
        # First check if we can use the vision's environment detection
        if hasattr(self.vision, 'current_environment') and self.vision.current_environment != "UNKNOWN":
            # Use the environment detection from Vision if available and confident
            if self.vision.environment_confidence > 0.7:  # Only use if confidence is high
                new_state = self.vision.current_environment
                utils.log(f"Using Vision's environment detection: {new_state} (confidence: {self.vision.environment_confidence:.2f})")
            else:
                # Fall back to text-based detection if confidence is low
                new_state = self.detect_game_state(game_state)
        else:
            # Fall back to traditional detection if Vision doesn't provide environment info
            new_state = self.detect_game_state(game_state)
        
        # Track state transitions
        if new_state != self.current_state:
            self.previous_states.append(self.current_state)
            if len(self.previous_states) > 5:  # Keep only the last 5 states
                self.previous_states.pop(0)
                
            self.state_transitions += 1
            utils.log(f"State transition: {self.current_state} -> {new_state}")
            self.current_state = new_state

        # Direct action mapping for common states
        if new_state in self.common_state_actions:
            return f"Press {self.common_state_actions[new_state]} button."

        # Intelligent caching: Check if we've seen this state recently
        cache_key = f"{new_state}:{hash(game_state[:100])}"  # Use first 100 chars for hashing
        if cache_key in self.instruction_cache:
            cached_instruction = self.instruction_cache[cache_key]
            utils.log(f"Using cached instruction for {new_state}: {cached_instruction}")
            return cached_instruction

        # Use state-based prompt template
        prompt = self.prompt_templates.get(new_state, self.prompt_templates["OVERWORLD"])
        utils.log(f"Generating instruction for state: {new_state}")

        # Tokenize and ensure input is float16
        input_ids = self.tokenizer(prompt, return_tensors="pt").input_ids.to(self.device).to(torch.long)

        # Generate response with optimized parameters for each state type
        with torch.inference_mode():
            # Adjust generation parameters based on state type
            temperature = 0.5  # Default temperature
            if new_state in ["DARK_CAVE", "MT_MOON", "ROCK_TUNNEL", "VICTORY_ROAD"]:
                temperature = 0.3  # More deterministic for caves
            elif new_state in ["BATTLE", "WILD_BATTLE", "TRAINER_BATTLE", "GYM_LEADER_BATTLE"]:
                temperature = 0.4  # Slightly more deterministic for battles
                
            output = self.llama_model.generate(
                input_ids, 
                max_new_tokens=25,
                temperature=temperature,
                top_p=0.85,
                repetition_penalty=1.1,
                stopping_criteria=self.stopping_criteria,
                pad_token_id=self.tokenizer.eos_token_id
            )

        # Decode output
        instruction = self.tokenizer.decode(output[0][input_ids.shape[1]:], skip_special_tokens=True).strip()
        utils.log(f"Llama instruction: {instruction}")

        # Cache the instruction
        if len(self.instruction_cache) >= self.cache_size:
            # Remove oldest entry
            oldest_key = next(iter(self.instruction_cache))
            del self.instruction_cache[oldest_key]
        self.instruction_cache[cache_key] = instruction

        return instruction if instruction else "Press A button to continue."
    
    def handle_dark_cave(self):
        """Special handling for dark caves without Flash"""
        # Check if we've been in dark cave for multiple consecutive states
        if len(self.previous_states) >= 3 and all(state == "DARK_CAVE" for state in self.previous_states[-3:]):
            utils.log("Stuck in dark cave, attempting to access Flash through menu")
            return "START"  # Access menu to potentially use Flash
        
        # Implement a simple wall-following algorithm for dark caves
        last_actions = getattr(self, '_last_dark_cave_actions', [])
        if not last_actions:
            utils.log("Starting dark cave navigation with RIGHT direction")
            self._last_dark_cave_actions = ["RIGHT"]
            return "RIGHT"
            
        # Simple navigation pattern: try to follow the right wall
        last_action = last_actions[-1]
        if len(last_actions) >= 2 and last_actions[-1] == last_actions[-2]:
            # If we've tried the same direction twice, try a different direction
            directions = ["UP", "RIGHT", "DOWN", "LEFT"]
            current_idx = directions.index(last_action)
            next_idx = (current_idx + 1) % 4
            next_action = directions[next_idx]
            utils.log(f"Changing direction in dark cave from {last_action} to {next_action}")
            last_actions.append(next_action)
            self._last_dark_cave_actions = last_actions[-5:] if len(last_actions) > 5 else last_actions
            return next_action
        else:
            # Continue in the same direction
            last_actions.append(last_action)
            self._last_dark_cave_actions = last_actions[-5:] if len(last_actions) > 5 else last_actions
            return last_action

    def get_next_action(self):
        """
        Uses Vision to obtain the game state and determine the next button press.
        """
        game_state = self.vision.get_game_state_text()
        utils.log(f"Game state from vision: {game_state}")

        # Special handling for common states
        if "TITLE SCREEN" in game_state.upper() or self.current_state == "TITLE_SCREEN":
            return "START"
            
        # Special handling for dark caves
        if self.current_state == "DARK_CAVE":
            return self.handle_dark_cave()

        # Generate task instruction
        instruction = self.get_llama_instruction(game_state)
        utils.log(f"Llama instruction: {instruction}")

        # Pass instruction to Vision for context-aware decision
        if hasattr(self.vision, 'get_next_action') and callable(getattr(self.vision, 'get_next_action')):
            action = self.vision.get_next_action(instruction)
            utils.log(f"Vision-based action with instruction: {action}")
            return action

        # Fallback extraction from instruction string if Vision doesn't provide action
        action = instruction.upper()
        if "PRESS A" in action:
            return "A"
        if "PRESS B" in action:
            return "B"
        if "PRESS START" in action:
            return "START"
        if "MOVE UP" in action:
            return "UP"
        if "MOVE DOWN" in action:
            return "DOWN"
        if "MOVE LEFT" in action:
            return "LEFT"
        if "MOVE RIGHT" in action:
            return "RIGHT"
        
        # Recursive call to try again for AI PLAYTHROUGH
        return self.get_next_action()  # Recursive call NEEDED AND NOT TO BE REMOVED for AI PLAYTHROUGH 
 
======================== 
emulator.py 
======================== 
import pyautogui
import pygetwindow as gw
import time
import cv2
import numpy as np
import config
import utils
import subprocess
import psutil
import win32gui
import win32con
import os
from gamepad import Gamepad

class Emulator:
    def __init__(self):
        self.polling_interval = config.POLLING_INTERVAL
        self.window_region = None
        self.last_keypress_time = 0
        self.process = None
        self.gamepad = Gamepad()
        self.window_title = "mGBA"

        self.attach_or_launch_emulator()
        success = self.update_window_region()
        if not success:
            utils.log("WARNING: Failed to detect mGBA window. Capturing may not work correctly.")

    def is_emulator_running(self):
        if self.process is None:
            return False
        return self.process.poll() is None if hasattr(self.process, 'poll') else self.process.is_running()

    def find_existing_emulator(self):
        for proc in psutil.process_iter(attrs=["pid", "name"]):
            if "mgba" in proc.info["name"].lower():
                utils.log(f"Attached to existing mGBA process (PID {proc.info['pid']})")
                return psutil.Process(proc.info["pid"])
        return None

    def update_window_region(self):
        """
        Detect mGBA window, crop out top menu bar, etc.
        """
        try:
            windows = gw.getWindowsWithTitle(self.window_title)
            if windows:
                window = windows[0]
                if window.isMinimized:
                    win32gui.ShowWindow(window._hWnd, win32con.SW_RESTORE)
                    time.sleep(0.5)
                
                x, y, width, height = window.left, window.top, window.width, window.height

                # Approx offsets
                top_menu_height = 120
                bottom_border = 88
                side_border = 80

                content_x = x + side_border
                content_y = y + top_menu_height
                content_width = width - (side_border * 2)
                content_height = height - top_menu_height - bottom_border

                self.window_region = (content_x, content_y, content_width, content_height)
                utils.log(f"Updated mGBA window region to: {self.window_region}")

                self.debug_capture()
                return True
            else:
                utils.log("No mGBA window found to update region.")
                return False
        except Exception as e:
            utils.log(f"Error updating window region: {e}")
            return False

    def debug_capture(self):
        if self.window_region is None:
            utils.log("No window region to capture.")
            return
        try:
            screenshot = pyautogui.screenshot(region=self.window_region)
            debug_path = os.path.join(config.FRAME_SAVE_DIR, "window_debug.png")
            screenshot.save(debug_path)
            utils.log(f"Saved debug capture: {debug_path}")
        except Exception as e:
            utils.log(f"Failed to save debug capture: {e}")

    def bring_emulator_to_front(self):
        try:
            windows = gw.getWindowsWithTitle(self.window_title)
            if windows:
                window = windows[0]
                win32gui.ShowWindow(window._hWnd, win32con.SW_RESTORE)
                win32gui.SetForegroundWindow(window._hWnd)
                utils.log("Brought mGBA window to the front.")
                self.update_window_region()
            else:
                utils.log("No mGBA window found to bring to front.")
        except Exception as e:
            utils.log(f"Failed to bring mGBA to front: {e}")

    def attach_or_launch_emulator(self):
        existing_process = self.find_existing_emulator()
        if existing_process:
            self.process = existing_process
        else:
            self.launch_emulator()

    def launch_emulator(self):
        if not self.is_emulator_running():
            utils.log("Launching mGBA emulator...")
            self.process = subprocess.Popen([config.EMULATOR_PATH, config.ROM_PATH])
            time.sleep(3)
            self.bring_emulator_to_front()

    def restart_emulator_if_closed(self):
        if self.process is None or (hasattr(self.process, 'is_running') and not self.process.is_running()):
            utils.log("Emulator closed unexpectedly. Restarting...")
            self.launch_emulator()

    def capture_screen(self):
        self.restart_emulator_if_closed()
        self.bring_emulator_to_front()

        if not self.update_window_region():
            utils.log("ERROR: Failed to update window region for capture.")
            if self.window_region:
                black_frame = np.zeros((self.window_region[3], self.window_region[2], 3), dtype=np.uint8)
                return black_frame
            else:
                return np.zeros((320, 288, 3), dtype=np.uint8)  # default fallback

        screenshot = pyautogui.screenshot(region=self.window_region)
        return cv2.cvtColor(np.array(screenshot), cv2.COLOR_RGB2BGR)

    def press_key(self, key):
        current_time = time.time()
        if current_time - self.last_keypress_time < 0.3:
            return
        self.restart_emulator_if_closed()
        self.bring_emulator_to_front()
        pyautogui.press(key)
        self.last_keypress_time = current_time
        utils.log(f"Pressed key: {key}")

    def press_button(self, action):
        """
        Use the virtual gamepad to press a button.
        """
        self.restart_emulator_if_closed()
        self.bring_emulator_to_front()
        self.gamepad.press_button(action)
        utils.log(f"Pressed gamepad button: {action}")

    def trigger_screenshot(self):
        utils.log("Triggering mGBA screenshot via gamepad...")
        self.gamepad.press_button("SCREENSHOT")

if __name__ == "__main__":
    emulator = Emulator()
    utils.log("Emulator test mode: capturing frames every 5 seconds.")
    utils.log(f"Initial window region: {emulator.window_region}")
    count = 0
    while count < 5:
        frame = emulator.capture_screen()
        utils.save_frame(frame, f"test_frame_{count}.png")
        utils.log(f"Captured test frame {count}")
        count += 1
        time.sleep(5)
 
 
======================== 
gamepad.py 
======================== 
import pyvjoy
import time
import config
import utils

class Gamepad:
    def __init__(self):
        """Initialize virtual gamepad using vJoy."""
        self.j = pyvjoy.VJoyDevice(1)  # Use vJoy Device 1

        # Updated Gamepad Mapping
        self.button_map = {
            "A": 1,
            "B": 2,
            "START": 8,
            "SELECT": 7,
            "UP": 3,
            "DOWN": 4,
            "LEFT": 5,
            "RIGHT": 6,
            "SCREENSHOT": 9  # New button mapped for mGBA screenshot
        }

        self.reset()

    def reset(self):
        """Reset all buttons on the virtual gamepad."""
        self.j.reset()
        self.j.reset_buttons()
        utils.log("vJoy gamepad reset to default state.")

    def press_button(self, action, is_manual=False):
        """Press a mapped button using vJoy.
        
        If is_manual=True, wait 5 seconds before pressing.
        """
        if action in self.button_map:
            button_id = self.button_map[action]

            if is_manual:
                utils.log(f"Waiting 5 seconds before pressing: {action}")
                time.sleep(5)

            utils.log(f"Pressing gamepad button: {action} (vJoy Button {button_id})")
            self.j.set_button(button_id, 1)
            time.sleep(0.2)  # Hold duration
            self.j.set_button(button_id, 0)  # Release button

        else:
            utils.log(f"Invalid action '{action}' sent to gamepad.")

if __name__ == "__main__":
    gp = Gamepad()
    print("Manual Gamepad Test Mode: Enter button names to simulate input.")
    while True:
        action = input("Enter button (A, B, START, SELECT, UP, DOWN, LEFT, RIGHT, SCREENSHOT) or 'exit': ").strip().upper()
        if action == "EXIT":
            break
        gp.press_button(action, is_manual=True)
 
 
======================== 
main.py 
======================== 
import time
import utils
import config
import torch
from emulator import Emulator
from vision import Vision
from decision import Decision

class PokemonTrainerAI:
    def __init__(self):
        # Set PyTorch to use deterministic algorithms for better performance
        if hasattr(torch, 'backends') and hasattr(torch.backends, 'cudnn'):
            torch.backends.cudnn.benchmark = True
            torch.backends.cudnn.deterministic = False
        
        # Initialize components
        self.emulator = Emulator()
        self.vision = Vision(self.emulator)
        self.decision = Decision(self.vision)

        self.action_count = 0
        self.game_completed = False
        self.failure_count = 0
        self.stuck_count = 0
        self.last_actions = []  # Track recent actions to detect stuck states
        self.last_action_time = time.time()
        
        # Track timing statistics for performance monitoring
        self.timing_stats = {
            "vision": [],
            "decision": [],
            "action": []
        }

    def is_stuck(self):
        """Check if we're stuck in the same game state repeating the same actions"""
        if len(self.last_actions) < 10:
            return False
            
        if len(set(self.last_actions[-10:])) == 1:
            self.stuck_count += 1
            utils.log(f"Detected possible stuck state - same action {self.last_actions[-1]} repeated 10 times")
            return True
            
        return False

    def perform_recovery_action(self):
        """Attempt to recover from stuck states with a sequence of actions"""
        utils.log("Performing recovery sequence...")
        recovery_sequence = ["B", "START", "B", "A", "DOWN", "DOWN", "A", "B"]
        
        for action in recovery_sequence:
            utils.log(f"Recovery action: {action}")
            self.emulator.press_button(action)
            time.sleep(0.5)  # Reduced wait time for faster recovery
            
        self.stuck_count = 0
        self.last_actions = []

    def log_performance_stats(self):
        """Log performance statistics periodically"""
        if self.action_count % 50 == 0:
            stats = {}
            for key, values in self.timing_stats.items():
                if values:
                    stats[key] = {
                        "avg": sum(values) / len(values),
                        "min": min(values),
                        "max": max(values),
                        "total": len(values)
                    }
            
            utils.log(f"Performance stats after {self.action_count} actions:")
            for key, metrics in stats.items():
                utils.log(f"  {key}: avg={metrics['avg']:.3f}s, min={metrics['min']:.3f}s, max={metrics['max']:.3f}s")
            
            # Reset stats after logging
            self.timing_stats = {k: [] for k in self.timing_stats.keys()}

    def run(self):
        utils.log("Starting Pokémon Blue AI training with optimized models...")
        
        utils.log("Pressing START button to begin game...")
        self.emulator.press_button("START")
        time.sleep(5)  # Reduced wait time
        
        while not self.game_completed:
            try:
                start_time = time.time()
                
                # Execute next action
                decision_start = time.time()
                action = self.decision.get_next_action()
                decision_time = time.time() - decision_start
                self.timing_stats["decision"].append(decision_time)
                
                # Press the button and wait 1 second for the game to update
                self.emulator.press_button(action)
                time.sleep(1)  # Wait for the game to reflect the action
                
                # Capture updated screenshot after waiting
                frame = self.emulator.capture_screen()
                utils.save_frame(frame, "post_action.png")  # Overwrite the same file
                
                # Get game state text from the updated frame
                vision_start = time.time()
                game_state_text = self.vision.get_game_state_text()
                vision_time = time.time() - vision_start
                self.timing_stats["vision"].append(vision_time)
                
                # Add action to history
                self.last_actions.append(action)
                if len(self.last_actions) > 20:
                    self.last_actions.pop(0)
                
                self.action_count += 1
                
                # Log action time and potential performance issues
                elapsed = time.time() - self.last_action_time
                self.last_action_time = time.time()
                
                if self.action_count % 10 == 0:
                    utils.log(f"Action {self.action_count}: {action} - Vision: {vision_time:.3f}s, Decision: {decision_time:.3f}s, Total: {elapsed:.3f}s")
                    self.log_performance_stats()
                
                # Check for stuck state and recovery
                if self.is_stuck() and self.stuck_count >= 3:
                    utils.log(f"Detected stuck state {self.stuck_count} times - attempting recovery")
                    self.perform_recovery_action()
                
                # Check for game completion
                if "Hall of Fame" in game_state_text:
                    utils.log(f"Game completed in {self.action_count} actions!")
                    self.game_completed = True
                
                # Dynamic polling interval based on game state
                if self.decision.current_state == "UNKNOWN":
                    time.sleep(config.POLLING_INTERVAL * 1.5)
                elif self.decision.current_state in ["TITLE_SCREEN", "DIALOGUE", "INTRO_SEQUENCE"]:
                    time.sleep(config.POLLING_INTERVAL * 0.7)  # Faster for simple states
                else:
                    time.sleep(config.POLLING_INTERVAL)
                    
            except Exception as e:
                self.failure_count += 1
                utils.log(f"Error during gameplay loop: {e}")
                if self.failure_count > 5:
                    utils.log("Too many consecutive failures. Restarting emulator...")
                    self.emulator.restart_emulator_if_closed()
                    self.failure_count = 0
                time.sleep(config.POLLING_INTERVAL * 2)

if __name__ == "__main__":
    # Try to free up memory before starting
    if torch.cuda.is_available():
        torch.cuda.empty_cache()
    
    PokemonTrainerAI().run() 
 
======================== 
memory_utils.py 
======================== 
"""
Utility functions for optimizing memory usage with PyTorch models.
This helps reduce VRAM consumption and allows models to run faster.
"""

import torch
import gc
import os
import psutil

def print_gpu_memory():
    """Print current GPU memory usage for monitoring."""
    if torch.cuda.is_available():
        for i in range(torch.cuda.device_count()):
            allocated = torch.cuda.memory_allocated(i) / 1024**2
            reserved = torch.cuda.memory_reserved(i) / 1024**2
            print(f"GPU Device {i}: {allocated:.2f} MB allocated, {reserved:.2f} MB reserved")
    else:
        print("No GPU available.")

def free_gpu_memory():
    """Free up unused GPU memory."""
    if torch.cuda.is_available():
        torch.cuda.empty_cache()
        gc.collect()
        print("Freed GPU memory.")
    else:
        print("No GPU available to free.")

def print_cpu_memory():
    """Print current CPU memory usage for this process."""
    process = psutil.Process(os.getpid())
    mem = process.memory_info().rss / 1024**2  # Convert bytes to MB
    print(f"CPU Memory usage: {mem:.2f} MB")

def free_cpu_memory():
    """Force garbage collection to free up CPU memory."""
    gc.collect()
    print("Forced garbage collection for CPU memory.")

if __name__ == "__main__":
    print("GPU Memory Info:")
    print_gpu_memory()
    print("\nCPU Memory Info:")
    print_cpu_memory()
    # Optionally free memory
    free_gpu_memory()
    free_cpu_memory()
 
 
======================== 
utils.py 
======================== 
import os
import cv2
import datetime
import config

def log(message):
    """Logs a message with a timestamp."""
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    log_message = f"[{timestamp}] {message}"
    print(log_message)
    log_file = os.path.join(config.LOG_DIR, "log.txt")
    with open(log_file, "a") as f:
        f.write(log_message + "\n")

def save_frame(frame, filename=None):
    """Saves a frame for debugging if enabled."""
    if config.SAVE_FRAMES:
        if filename is None:
            filename = f"frame_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
        filepath = os.path.join(config.FRAME_SAVE_DIR, filename)
        cv2.imwrite(filepath, frame)
        log(f"Saved frame: {filepath}")

def map_action_to_key(action):
    """Maps an action string to the emulator's keybinds."""
    return config.KEY_MAPPING.get(action.upper(), None)
 
 
======================== 
vision.py 
======================== 
import time
import utils
import config
import torch
from transformers import AutoModelForCausalLM
import cv2
import numpy as np
import os
from PIL import Image

class Vision:
    """
    Optimized Moondream-based vision class with enhanced game state detection capabilities.
    This class captures the screen from the emulator and uses the Moondream model
    to analyze the game state with improved prompts for specialized areas like caves.
    """
    def __init__(self, emulator=None):
        self.emulator = emulator
        self.device = "cuda" if torch.cuda.is_available() else "cpu"

        # Load Moondream model with full float16 precision for compatibility
        self.model = AutoModelForCausalLM.from_pretrained(
            config.VISION_MODEL_PATH,
            revision="2025-01-09",
            trust_remote_code=True,
            device_map={"": self.device},
            torch_dtype=torch.float16  # Use full FP16 precision
        )
        
        # Optionally compile the model for faster inference if enabled in config
        if torch.cuda.is_available() and config.TORCH_COMPILE:
            self.model = torch.compile(self.model)
        
        utils.log(f"Moondream model initialized on: {self.device} with full float16 precision")

        # Valid button actions
        self.valid_buttons = ["UP", "DOWN", "LEFT", "RIGHT", "A", "B", "START", "SELECT"]

        # Enhanced base prompt for better game state detection
        self.base_prompt = """
Describe this Pokémon Blue game screen in detail. Focus on:
1. Game state (be specific: title screen, dialogue, battle type, menu, overworld, cave, dark cave, gym)
2. All visible text or menu options
3. Character and NPC positions
4. Environment details (indoors, outdoors, cave, water)
5. Battle information if present (Pokémon names, HP, moves)
6. Any obstacles or interactive elements (doors, signs, trees, boulders)

Be comprehensive but concise. Include environmental cues that indicate location type.
"""

        # Environment-specific prompts for better detection
        self.specialized_prompts = {
            "CAVE_DETECTION": """
Is the player in a cave environment? Look for:
- Dark/rocky surroundings
- Limited visibility
- Cave entrance/exit
- Rock formations
- Multiple tunnel paths
Describe the cave features and any visible paths or items.
""",
            "DARK_CAVE_DETECTION": """
Is this a dark cave where Flash is needed? Look for:
- Very limited visibility (small visible area around player)
- Black surroundings
- Difficulty seeing paths or walls
Describe the visibility level and any visible elements.
"""
        }

        # Image caching to avoid reprocessing identical frames
        self.image_cache = {}
        self.cache_limit = 10  # Increased cache size
        
        self.consecutive_title_screens = 0
        self.frames_captured = 0
        self.last_frame_hash = None
        
        # Track environmental context across frames
        self.current_environment = "UNKNOWN"
        self.environment_confidence = 0
        self.environment_history = []  # Track last 5 environment detections
        self.max_history = 5

    def capture_screen(self):
        """
        Capture the emulator screen as a PIL image.
        """
        if not self.emulator:
            utils.log("WARNING: No emulator provided to Vision. Returning blank image.")
            return Image.new('RGB', (160, 144), color=(0, 0, 0))
        
        self.frames_captured += 1
        frame = self.emulator.capture_screen()
        
        # Save only every Nth frame to reduce disk I/O
        if self.frames_captured % config.FRAME_LOGGING_FREQUENCY == 0:
            utils.save_frame(frame, f"frame_{self.frames_captured}.png")
            
        # Convert BGR (OpenCV) to RGB and return PIL image
        return Image.fromarray(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB))
    
    def _hash_image(self, image):
        """Create a simple hash for image caching."""
        # Convert to small grayscale for faster hashing
        img_small = image.resize((32, 32)).convert('L')
        img_array = np.array(img_small)
        return hash(img_array.tobytes())
    
    def detect_environment(self, description):
        """
        Analyze the screen description to detect specific environments.
        Returns the detected environment type.
        """
        description_upper = description.upper()
        
        # Cave detection with priority on dark caves
        if any(term in description_upper for term in ["DARK CAVE", "CAN'T SEE", "LIMITED VISIBILITY", "FLASH NEEDED"]):
            return "DARK_CAVE"
        if any(term in description_upper for term in ["MT MOON", "MT. MOON"]):
            return "MT_MOON"
        if "ROCK TUNNEL" in description_upper:
            return "ROCK_TUNNEL"
        if "VICTORY ROAD" in description_upper:
            return "VICTORY_ROAD"
        if any(term in description_upper for term in ["CAVE", "TUNNEL", "UNDERGROUND", "ROCKY"]):
            return "CAVE"
            
        # Building interiors
        if any(term in description_upper for term in ["POKEMON CENTER", "POKÉMON CENTER", "NURSE JOY", "HEALING"]):
            return "POKEMON_CENTER"
        if any(term in description_upper for term in ["MART", "SHOP", "STORE", "CLERK", "BUY"]):
            return "POKEMON_MART"
        if "GYM" in description_upper:
            return "GYM"
        if any(term in description_upper for term in ["HOUSE", "BUILDING", "INSIDE", "INTERIOR", "INDOOR"]):
            return "BUILDING"
            
        # Battle types
        if "GYM LEADER" in description_upper and "BATTLE" in description_upper:
            return "GYM_LEADER_BATTLE"
        if "TRAINER" in description_upper and "BATTLE" in description_upper:
            return "TRAINER_BATTLE"
        if "WILD" in description_upper and "BATTLE" in description_upper:
            return "WILD_BATTLE"
        if any(term in description_upper for term in ["BATTLE", "FIGHT", "POKEMON VS", "POKÉMON VS"]):
            return "BATTLE"
            
        # Other specific states
        if any(term in description_upper for term in ["TITLE SCREEN", "BLUE VERSION", "PRESS START"]):
            return "TITLE_SCREEN"
        if any(term in description_upper for term in ["TEXT BOX", "DIALOGUE", "TALKING", "MESSAGE"]):
            return "DIALOGUE"
        if any(term in description_upper for term in ["MENU", "OPTIONS", "ITEMS", "POKEMON LIST", "POKÉMON LIST"]):
            return "MENU"
            
        # Default to overworld
        return "OVERWORLD"
    
    def update_environment_tracking(self, detected_env):
        """
        Update environment tracking based on new detection,
        using a history-based approach for stability.
        """
        # Add to history and maintain max size
        self.environment_history.append(detected_env)
        if len(self.environment_history) > self.max_history:
            self.environment_history.pop(0)
            
        # Count occurrences of each environment in history
        env_counts = {}
        for env in self.environment_history:
            env_counts[env] = env_counts.get(env, 0) + 1
            
        # Find most common environment in history
        most_common_env = max(env_counts.items(), key=lambda x: x[1])
        most_common_count = most_common_env[1]
        confidence = most_common_count / len(self.environment_history)
        
        # Update current environment if confidence is high enough
        if confidence >= 0.6:  # 60% threshold for changing environment
            prev_env = self.current_environment
            self.current_environment = most_common_env[0]
            self.environment_confidence = confidence
            
            if prev_env != self.current_environment:
                utils.log(f"Environment change: {prev_env} -> {self.current_environment} (confidence: {confidence:.2f})")
        
        return self.current_environment
    
    def get_game_state_text(self):
        """
        Return a descriptive text about the current screen with enhanced environment detection.
        """
        image = self.capture_screen()
        image_hash = self._hash_image(image)
        
        # Check if this frame is in cache
        if image_hash in self.image_cache:
            cached_description = self.image_cache[image_hash]
            # Still update environment tracking with cached description
            detected_env = self.detect_environment(cached_description)
            self.update_environment_tracking(detected_env)
            utils.log(f"Using cached frame description (environment: {self.current_environment})")
            return cached_description
            
        # Check if this is the same as last frame
        if image_hash == self.last_frame_hash:
            cached_description = self.image_cache.get(image_hash, "Game screen with no changes")
            utils.log("Frame unchanged, reusing last description")
            return cached_description
        
        self.last_frame_hash = image_hash
        
        # Choose prompt based on recent environment history for better specificity
        prompt_to_use = self.base_prompt
        
        # If we've consistently detected a cave, use specialized cave prompt
        if any(env in ["CAVE", "MT_MOON", "ROCK_TUNNEL", "VICTORY_ROAD"] for env in self.environment_history[-2:]):
            prompt_to_use = self.specialized_prompts["CAVE_DETECTION"]
            utils.log("Using specialized cave detection prompt")
        
        # If we've detected a dark cave, use specialized dark cave prompt
        elif "DARK_CAVE" in self.environment_history[-2:]:
            prompt_to_use = self.specialized_prompts["DARK_CAVE_DETECTION"]
            utils.log("Using specialized dark cave detection prompt")
        
        # Generate caption using Moondream
        with torch.inference_mode():
            caption = self.model.query(
                image,
                prompt_to_use,
            )["answer"]
            
        utils.log(f"Moondream Screen Description: {caption}")
        
        # Update environment tracking
        detected_env = self.detect_environment(caption)
        self.update_environment_tracking(detected_env)
        
        # Update cache
        if len(self.image_cache) >= self.cache_limit:
            oldest = next(iter(self.image_cache))
            del self.image_cache[oldest]
        self.image_cache[image_hash] = caption
        
        # More precise title screen tracking
        if ("title screen" in caption.lower() or "blue version" in caption.lower()) and \
           ("professor" not in caption.lower() and "oak" not in caption.lower()):
            self.consecutive_title_screens += 1
            utils.log(f"Title screen detection count: {self.consecutive_title_screens}")
        else:
            self.consecutive_title_screens = 0
            
        return caption

    def get_context_aware_prompt(self, task_instruction=None):
        """
        Generate a context-aware prompt based on the current environment.
        """
        # Base prompt parts
        base_prefix = "You are playing Pokémon Blue. "
        base_suffix = "\nReply with ONLY one button: UP, DOWN, LEFT, RIGHT, A, B, START, SELECT"
        
        # Environment-specific instructions
        env_instructions = {
            "DARK_CAVE": "You're in a dark cave with limited visibility. Navigate carefully and consider using Flash. ",
            "CAVE": "You're exploring a cave. Watch for wild Pokémon and look for items. ",
            "MT_MOON": "You're in Mt. Moon. Watch for Zubat encounters and fossil researchers. ",
            "ROCK_TUNNEL": "You're in Rock Tunnel. This cave is complex with many trainers. ",
            "VICTORY_ROAD": "You're in Victory Road. This is a challenging cave with strength puzzles. ",
            "POKEMON_CENTER": "You're in a Pokémon Center. Consider talking to Nurse Joy to heal your Pokémon. ",
            "POKEMON_MART": "You're in a Pokémon Mart. You can buy items from the clerk. ",
            "GYM": "You're in a Pokémon Gym. Navigate to the Gym Leader while defeating trainers. ",
            "WILD_BATTLE": "You're in a wild Pokémon battle. Choose fight for moves, or other options like Run. ",
            "TRAINER_BATTLE": "You're in a trainer battle. You must win to proceed. Choose your moves wisely. ",
            "GYM_LEADER_BATTLE": "You're battling a Gym Leader! This is an important battle for a badge. ",
            "TITLE_SCREEN": "You're at the title screen. ",
            "DIALOGUE": "You're in a dialogue or text screen. ",
            "MENU": "You're navigating a menu. Use directional buttons to navigate and A to select. ",
            "OVERWORLD": "You're exploring the overworld. "
        }
        
        # Get environment-specific instruction or use general default
        env_instruction = env_instructions.get(self.current_environment, "Choose a button based on what you see. ")
        
        # Include task instruction if provided, otherwise use environment-based guidance
        if task_instruction:
            prompt = f"{base_prefix}Choose a button based on this instruction:\n{task_instruction}{base_suffix}"
        else:
            prompt = f"{base_prefix}{env_instruction}{base_suffix}"
            
        return prompt

    def get_next_action(self, task_instruction=None):
        """
        Use the Moondream model to choose the next button press with environment awareness.
        """
        # Title screen fast path
        if self.consecutive_title_screens >= 2:
            utils.log("Multiple title screens detected. Forcing START button.")
            return "START"
        
        image = self.capture_screen()
        
        # Generate context-aware prompt
        prompt = self.get_context_aware_prompt(task_instruction)
        utils.log(f"Using prompt: {prompt}")
        
        # Generate with optimized settings
        with torch.inference_mode():
            response = self.model.query(
                image,
                prompt,
            )["answer"]
            
        utils.log(f"Moondream raw decision: {response}")
        action = response.strip().upper()
        
        # More specific title screen check to avoid false triggers
        if ("TITLE SCREEN" in action or "BLUE VERSION" in action) and \
           ("PROFESSOR" not in action and "OAK" not in action):
            utils.log("Title screen text detected in response, overriding to START")
            return "START"
        
        # Extract button by direct pattern matching
        for button in self.valid_buttons:
            if button in action:
                utils.log(f"Extracted button '{button}' from '{action}'")
                return button
                
        # Environment-specific fallbacks
        if self.current_environment == "DARK_CAVE":
            utils.log("In dark cave with no clear action. Defaulting to START to access Flash.")
            return "START"
        
        if self.current_environment == "DIALOGUE":
            utils.log("In dialogue with no clear action. Defaulting to A.")
            return "A"
        
        # Default to "redo" if no valid button found - NEEDED FOR AI PLAYTHROUGH
        utils.log(f"No valid button in '{action}'. Defaulting to RETRYING.")
        return self.get_next_action()  # Recursive call to try again 
 
