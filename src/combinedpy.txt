======================== 
config.py 
======================== 
import os

# === Vision Model Settings ===
VISION_MODEL_PATH = "vikhyatk/moondream2"

# === Memory Optimization Settings ===
# Enable memory optimizations (8-bit quantization and offloading)
USE_8BIT_QUANTIZATION = True
USE_OFFLOADING = True

# === ROM & Emulator Settings ===
ROM_PATH = "roms/pokemon_blue.gb"
POLLING_INTERVAL = 0.8  # Reduced polling interval for faster gameplay
EMULATOR_PATH = "C:\\Program Files\\mGBA\\mGBA.exe"

# Screenshot location (same as ROM directory)
SCREENSHOT_PATH = os.path.join(os.path.dirname(ROM_PATH), "screenshot.png")

# === Debugging & Logging ===
LOG_DIR = os.path.join(os.getcwd(), "logs")
os.makedirs(LOG_DIR, exist_ok=True)  # Ensure log directory exists
SAVE_FRAMES = True
FRAME_SAVE_DIR = os.path.join(os.getcwd(), "logs", "frames")
os.makedirs(FRAME_SAVE_DIR, exist_ok=True)

# Reduce frame logging frequency to improve performance
FRAME_LOGGING_FREQUENCY = 20  # Save only every Nth frame

# === Cache Settings ===
# Enhanced caching to reduce model calls
VISION_CACHE_SIZE = 10
DECISION_CACHE_SIZE = 20
ENABLE_SIMILARITY_CACHE = True  # Enable fuzzy matching for cache hits

# === Input Settings ===
KEY_MAPPING = {
    "UP": "up",
    "DOWN": "down",
    "LEFT": "left",
    "RIGHT": "right",
    "A": "z",      # Adjust based on emulator key mapping
    "B": "x",
    "START": "enter",
    "SELECT": "backspace",
    "SCREENSHOT": "F12"  # New key for triggering mGBA screenshot
}

# === Performance Settings ===
# Performance optimization flags
TORCH_COMPILE = True      # Use torch.compile for models if available
HALF_PRECISION = True     # Use FP16 precision
LOW_CPU_USAGE = True      # Enable low CPU memory usage 
 
======================== 
decision.py 
======================== 
import torch
from transformers import AutoModelForCausalLM, AutoTokenizer, StoppingCriteria, StoppingCriteriaList
import utils

class StopOnTokens(StoppingCriteria):
    def __init__(self, stop_token_ids):
        self.stop_token_ids = stop_token_ids
    
    def __call__(self, input_ids, scores, **kwargs):
        for stop_id in self.stop_token_ids:
            if input_ids[0][-1] == stop_id:
                return True
        return False

class Decision:
    """
    Decision layer that leverages Llama-3.2-3B to generate concise task instructions
    from the game state and then delegates to Moondream (via Vision) to determine the
    next button press.
    """
    def __init__(self, vision, device=None):
        self.vision = vision
        # Use CUDA if available, otherwise CPU
        self.device = device or ("cuda" if torch.cuda.is_available() else "cpu")
        self.llama_model_name = "meta-llama/Llama-3.2-3B"
        
        # Initialize Llama tokenizer 
        self.tokenizer = AutoTokenizer.from_pretrained(self.llama_model_name)
        
        # Load model with 8-bit quantization to reduce VRAM usage
        self.llama_model = AutoModelForCausalLM.from_pretrained(
            self.llama_model_name,
            device_map={"": self.device},
            torch_dtype=torch.float16,  # Use half precision
            load_in_8bit=True,  # Use 8-bit quantization
            low_cpu_mem_usage=True
        )
        
        # Prepare stopping criteria for generation
        stop_words = [".", "\n"]
        stop_token_ids = [self.tokenizer.encode(word)[-1] for word in stop_words]
        self.stopping_criteria = StoppingCriteriaList([StopOnTokens(stop_token_ids)])
        
        utils.log(f"Llama model initialized on: {self.device} with 8-bit quantization")
        
        # Precompile prompts for faster generation
        self.prompt_templates = self._create_prompt_templates()
        
        # Track the current game state
        self.current_state = "UNKNOWN"
        self.previous_states = []
        self.state_transitions = 0
        
        # Improved cache for recently seen game states
        self.instruction_cache = {}
        self.cache_size = 20  # Increased cache size for better hit rates
        
        # State-based action lookup for common states - bypass LLM completely
        self.common_state_actions = {
            "TITLE_SCREEN": "START",
            "DIALOGUE": "A",
            "INTRO_SEQUENCE": "A"
        }

    def _create_prompt_templates(self):
        """Create and return a dictionary of pre-formatted prompt templates for each state."""
        templates = {}
        
        # Simplified prompts with fewer tokens to process
        templates["TITLE_SCREEN"] = """
You're at the Pokémon Blue title screen.
Your response must be EXACTLY "Press START button to begin the game."
"""
        
        templates["INTRO_SEQUENCE"] = """
You're in the Pokémon Blue introduction with Professor Oak.
Game state: \"\"\"{}\"\"\"
Your response must be EXACTLY "Press A button to continue dialogue."
"""
        
        templates["DIALOGUE"] = """
You're in dialogue or reading text in Pokémon Blue.
Game state: \"\"\"{}\"\"\"
Your response must be EXACTLY "Press A button to continue dialogue."
"""
        
        templates["BATTLE"] = """
You're in a Pokémon battle.
Game state: \"\"\"{}\"\"\"
Respond with EXACTLY one of:
"Move UP to navigate battle menu."
"Move DOWN to navigate battle menu."
"Press A to select the current option."
"""
        
        templates["MENU"] = """
You're navigating a menu in Pokémon Blue.
Game state: \"\"\"{}\"\"\"
Respond with EXACTLY one of:
"Move UP to navigate menu."
"Move DOWN to navigate menu."
"Press A to select the current option."
"Press B to exit the menu."
"""
        
        templates["OVERWORLD"] = """
You're exploring the Pokémon Blue overworld.
Game state: \"\"\"{}\"\"\"
Respond with EXACTLY one of:
"Move UP to explore."
"Move DOWN to explore."
"Move LEFT to explore."
"Move RIGHT to explore."
"Press A to interact."
"Press START to open menu."
"""
        
        return templates

    def detect_game_state(self, game_state_text):
        """
        Analyzes the game state description to determine what stage of the game we're in.
        Returns a string representing the current game state.
        """
        if self.current_state != "UNKNOWN":
            self.previous_states.append(self.current_state)
            if len(self.previous_states) > 5:
                self.previous_states.pop(0)
        
        # Optimized text matching with early returns for common states
        game_state_upper = game_state_text.upper()
        
        # Check for title screen first (most important for cold starts)
        if "BLUE VERSION" in game_state_upper or "POKÉMON LOGO" in game_state_upper or "TITLE SCREEN" in game_state_upper:
            return "TITLE_SCREEN"
            
        # Check for battle (common state that needs specific handling)
        if "BATTLE" in game_state_upper or "FIGHT" in game_state_upper or "ATTACK" in game_state_upper:
            return "BATTLE"
            
        # Check dialogue and intro (common and simple states)
        if "TEXT" in game_state_upper or "DIALOGUE" in game_state_upper:
            return "DIALOGUE"
        if "OAK" in game_state_upper or "PROFESSOR" in game_state_upper:
            return "INTRO_SEQUENCE"
            
        # Check for menu state
        if "MENU" in game_state_upper or "OPTION" in game_state_upper or "ITEMS" in game_state_upper:
            return "MENU"
            
        # Default to overworld
        return "OVERWORLD"

    def get_cached_instruction(self, game_state_text, state):
        """Try to retrieve a cached instruction for similar game states."""
        # First check for exact match
        if game_state_text in self.instruction_cache:
            utils.log("Using exact cached instruction")
            return self.instruction_cache[game_state_text]
            
        # If no exact match, look for similarities in key phrases
        # This improves cache hit rate for similar descriptions
        for cached_text, instruction in self.instruction_cache.items():
            if state == self.detect_game_state(cached_text):  # Only compare within same state
                # Check for significant phrase overlap
                if self._text_similarity(game_state_text, cached_text) > 0.6:
                    utils.log("Using similar cached instruction")
                    return instruction
                    
        return None
        
    def _text_similarity(self, text1, text2):
        """Simple text similarity measure based on word overlap"""
        words1 = set(text1.lower().split())
        words2 = set(text2.lower().split())
        
        if not words1 or not words2:
            return 0
            
        overlap = len(words1.intersection(words2))
        union = len(words1.union(words2))
        
        return overlap / union

    def update_cache(self, game_state_text, instruction):
        """Add or update the instruction cache."""
        # Simple FIFO cache
        if len(self.instruction_cache) >= self.cache_size:
            # Remove oldest entry (first key)
            oldest_key = next(iter(self.instruction_cache))
            del self.instruction_cache[oldest_key]
        
        self.instruction_cache[game_state_text] = instruction

    def get_llama_instruction(self, game_state):
        """
        Uses Llama to convert a game state description into a concise instruction task.
        Optimized with improved caching and fast paths for common states.
        """
        new_state = self.detect_game_state(game_state)
        if new_state != self.current_state:
            self.state_transitions += 1
            utils.log(f"State transition: {self.current_state} -> {new_state}")
            self.current_state = new_state
        
        # Fast path shortcuts for common states - completely bypass LLM
        if new_state in self.common_state_actions:
            action = self.common_state_actions[new_state]
            if new_state == "TITLE_SCREEN":
                return "Press START button to begin the game."
            elif new_state == "DIALOGUE" or new_state == "INTRO_SEQUENCE":
                return "Press A button to continue dialogue."
        
        # Check cache for similar game states
        cached_instruction = self.get_cached_instruction(game_state, self.current_state)
        if cached_instruction:
            return cached_instruction

        # Select the appropriate prompt template
        template = self.prompt_templates.get(self.current_state, self.prompt_templates["OVERWORLD"])
        prompt = template.format(game_state)

        utils.log(f"Generating instruction for state: {self.current_state}")
        
        # Generation with optimized parameters for speed
        base_temperature = 0.5  # Lower temperature for more deterministic outputs
        max_tokens = 25  # Reduced token count for faster generation
        valid_indicators = ["PRESS A", "PRESS B", "PRESS START", "MOVE UP", "MOVE DOWN", "MOVE LEFT", "MOVE RIGHT"]
        
        # Use dynamic batch size based on input length to optimize throughput
        input_ids = self.tokenizer(prompt, return_tensors="pt").input_ids.to(self.device)
        
        with torch.inference_mode():  # Use inference_mode instead of no_grad for slightly better performance
            output_ids = self.llama_model.generate(
                input_ids, 
                max_new_tokens=max_tokens,
                temperature=base_temperature,
                num_return_sequences=1,
                do_sample=True,
                top_p=0.85,  # Reduced from 0.9
                repetition_penalty=1.1,  # Reduced from 1.2
                pad_token_id=self.tokenizer.eos_token_id  # Explicitly set pad token
            )
        
        instruction = self.tokenizer.decode(output_ids[0][input_ids.shape[1]:], skip_special_tokens=True).strip()
        utils.log(f"Llama instruction: {instruction}")
        
        # Check if we got a valid instruction
        if any(ind in instruction.upper() for ind in valid_indicators):
            # Cache this successful instruction
            self.update_cache(game_state, instruction)
            return instruction
        
        # If instruction isn't valid, use state-based fallbacks for reliability
        if self.current_state == "TITLE_SCREEN":
            return "Press START button to begin the game."
        if self.current_state == "DIALOGUE" or self.current_state == "INTRO_SEQUENCE":
            return "Press A button to continue dialogue."
        if self.current_state == "OVERWORLD":
            return "Move RIGHT to explore."
        if self.current_state == "BATTLE":
            return "Press A to select the current option."
        if self.current_state == "MENU":
            return "Press A to select the current option."
            
        # Generic fallback if all else fails
        return "Press A button to continue."

    def get_next_action(self):
        """
        Uses Vision to obtain the game state text, then returns a button press decision.
        Optimized to reduce unnecessary processing.
        """
        game_state = self.vision.get_game_state_text()
        utils.log(f"Game state from vision: {game_state}")
        
        # Ultra-fast path: title screen detection
        if "BLUE VERSION" in game_state.upper() or "POKÉMON LOGO" in game_state.upper() or "TITLE SCREEN" in game_state.upper():
            utils.log("Title screen detected from game state. Forcing START button.")
            self.current_state = "TITLE_SCREEN"
            return "START"

        # Get instruction
        instruction = self.get_llama_instruction(game_state)
        utils.log(f"Llama instruction: {instruction}")
        
        # Ensure title screen gets START button
        if self.current_state == "TITLE_SCREEN":
            utils.log("Title screen state detected. Forcing START button.")
            return "START"

        # Extract action from instruction using direct pattern matching
        instruction_upper = instruction.upper()
        if "PRESS A" in instruction_upper:
            return "A"
        elif "PRESS B" in instruction_upper:
            return "B"
        elif "PRESS START" in instruction_upper:
            return "START"
        elif "MOVE UP" in instruction_upper:
            return "UP"
        elif "MOVE DOWN" in instruction_upper:
            return "DOWN"
        elif "MOVE LEFT" in instruction_upper:
            return "LEFT"
        elif "MOVE RIGHT" in instruction_upper:
            return "RIGHT"
        else:
            # If we're here, use state-based defaults
            if self.current_state == "DIALOGUE" or self.current_state == "INTRO_SEQUENCE":
                return "A"
            elif self.current_state == "TITLE_SCREEN":
                return "START"
            else:
                # Default to a safe action when uncertain
                return self.get_next_action()  # Recursive call to try again for AI PLAYTHROUGH 
 
======================== 
emulator.py 
======================== 
import pyautogui
import pygetwindow as gw
import time
import cv2
import numpy as np
import config
import utils
import subprocess
import psutil
import win32gui
import win32con
import os
from gamepad import Gamepad

class Emulator:
    def __init__(self):
        self.polling_interval = config.POLLING_INTERVAL
        self.window_region = None
        self.last_keypress_time = 0
        self.process = None
        self.gamepad = Gamepad()
        self.window_title = "mGBA"

        self.attach_or_launch_emulator()
        success = self.update_window_region()
        if not success:
            utils.log("WARNING: Failed to detect mGBA window. Capturing may not work correctly.")

    def is_emulator_running(self):
        if self.process is None:
            return False
        return self.process.poll() is None if hasattr(self.process, 'poll') else self.process.is_running()

    def find_existing_emulator(self):
        for proc in psutil.process_iter(attrs=["pid", "name"]):
            if "mgba" in proc.info["name"].lower():
                utils.log(f"Attached to existing mGBA process (PID {proc.info['pid']})")
                return psutil.Process(proc.info["pid"])
        return None

    def update_window_region(self):
        """
        Detect mGBA window, crop out top menu bar, etc.
        """
        try:
            windows = gw.getWindowsWithTitle(self.window_title)
            if windows:
                window = windows[0]
                if window.isMinimized:
                    win32gui.ShowWindow(window._hWnd, win32con.SW_RESTORE)
                    time.sleep(0.5)
                
                x, y, width, height = window.left, window.top, window.width, window.height

                # Approx offsets
                top_menu_height = 120
                bottom_border = 110
                side_border = 85

                content_x = x + side_border
                content_y = y + top_menu_height
                content_width = width - (side_border * 2)
                content_height = height - top_menu_height - bottom_border

                self.window_region = (content_x, content_y, content_width, content_height)
                utils.log(f"Updated mGBA window region to: {self.window_region}")

                self.debug_capture()
                return True
            else:
                utils.log("No mGBA window found to update region.")
                return False
        except Exception as e:
            utils.log(f"Error updating window region: {e}")
            return False

    def debug_capture(self):
        if self.window_region is None:
            utils.log("No window region to capture.")
            return
        try:
            screenshot = pyautogui.screenshot(region=self.window_region)
            debug_path = os.path.join(config.FRAME_SAVE_DIR, "window_debug.png")
            screenshot.save(debug_path)
            utils.log(f"Saved debug capture: {debug_path}")
        except Exception as e:
            utils.log(f"Failed to save debug capture: {e}")

    def bring_emulator_to_front(self):
        try:
            windows = gw.getWindowsWithTitle(self.window_title)
            if windows:
                window = windows[0]
                win32gui.ShowWindow(window._hWnd, win32con.SW_RESTORE)
                win32gui.SetForegroundWindow(window._hWnd)
                utils.log("Brought mGBA window to the front.")
                self.update_window_region()
            else:
                utils.log("No mGBA window found to bring to front.")
        except Exception as e:
            utils.log(f"Failed to bring mGBA to front: {e}")

    def attach_or_launch_emulator(self):
        existing_process = self.find_existing_emulator()
        if existing_process:
            self.process = existing_process
        else:
            self.launch_emulator()

    def launch_emulator(self):
        if not self.is_emulator_running():
            utils.log("Launching mGBA emulator...")
            self.process = subprocess.Popen([config.EMULATOR_PATH, config.ROM_PATH])
            time.sleep(3)
            self.bring_emulator_to_front()

    def restart_emulator_if_closed(self):
        if self.process is None or (hasattr(self.process, 'is_running') and not self.process.is_running()):
            utils.log("Emulator closed unexpectedly. Restarting...")
            self.launch_emulator()

    def capture_screen(self):
        self.restart_emulator_if_closed()
        self.bring_emulator_to_front()

        if not self.update_window_region():
            utils.log("ERROR: Failed to update window region for capture.")
            if self.window_region:
                black_frame = np.zeros((self.window_region[3], self.window_region[2], 3), dtype=np.uint8)
                return black_frame
            else:
                return np.zeros((320, 288, 3), dtype=np.uint8)  # default fallback

        screenshot = pyautogui.screenshot(region=self.window_region)
        return cv2.cvtColor(np.array(screenshot), cv2.COLOR_RGB2BGR)

    def press_key(self, key):
        current_time = time.time()
        if current_time - self.last_keypress_time < 0.3:
            return
        self.restart_emulator_if_closed()
        self.bring_emulator_to_front()
        pyautogui.press(key)
        self.last_keypress_time = current_time
        utils.log(f"Pressed key: {key}")

    def press_button(self, action):
        """
        Use the virtual gamepad to press a button.
        """
        self.restart_emulator_if_closed()
        self.bring_emulator_to_front()
        self.gamepad.press_button(action)
        utils.log(f"Pressed gamepad button: {action}")

    def trigger_screenshot(self):
        utils.log("Triggering mGBA screenshot via gamepad...")
        self.gamepad.press_button("SCREENSHOT")

if __name__ == "__main__":
    emulator = Emulator()
    utils.log("Emulator test mode: capturing frames every 5 seconds.")
    utils.log(f"Initial window region: {emulator.window_region}")
    count = 0
    while count < 5:
        frame = emulator.capture_screen()
        utils.save_frame(frame, f"test_frame_{count}.png")
        utils.log(f"Captured test frame {count}")
        count += 1
        time.sleep(5)
 
 
======================== 
gamepad.py 
======================== 
import pyvjoy
import time
import config
import utils

class Gamepad:
    def __init__(self):
        """Initialize virtual gamepad using vJoy."""
        self.j = pyvjoy.VJoyDevice(1)  # Use vJoy Device 1

        # Updated Gamepad Mapping
        self.button_map = {
            "A": 1,
            "B": 2,
            "START": 8,
            "SELECT": 7,
            "UP": 3,
            "DOWN": 4,
            "LEFT": 5,
            "RIGHT": 6,
            "SCREENSHOT": 9  # New button mapped for mGBA screenshot
        }

        self.reset()

    def reset(self):
        """Reset all buttons on the virtual gamepad."""
        self.j.reset()
        self.j.reset_buttons()
        utils.log("vJoy gamepad reset to default state.")

    def press_button(self, action, is_manual=False):
        """Press a mapped button using vJoy.
        
        If is_manual=True, wait 5 seconds before pressing.
        """
        if action in self.button_map:
            button_id = self.button_map[action]

            if is_manual:
                utils.log(f"Waiting 5 seconds before pressing: {action}")
                time.sleep(5)

            utils.log(f"Pressing gamepad button: {action} (vJoy Button {button_id})")
            self.j.set_button(button_id, 1)
            time.sleep(0.2)  # Hold duration
            self.j.set_button(button_id, 0)  # Release button

        else:
            utils.log(f"Invalid action '{action}' sent to gamepad.")

if __name__ == "__main__":
    gp = Gamepad()
    print("Manual Gamepad Test Mode: Enter button names to simulate input.")
    while True:
        action = input("Enter button (A, B, START, SELECT, UP, DOWN, LEFT, RIGHT, SCREENSHOT) or 'exit': ").strip().upper()
        if action == "EXIT":
            break
        gp.press_button(action, is_manual=True)
 
 
======================== 
main.py 
======================== 
import time
import utils
import config
import torch
from emulator import Emulator
from vision import Vision
from decision import Decision

class PokemonTrainerAI:
    def __init__(self):
        # Set PyTorch to use deterministic algorithms for better performance
        if hasattr(torch, 'backends') and hasattr(torch.backends, 'cudnn'):
            torch.backends.cudnn.benchmark = True
            torch.backends.cudnn.deterministic = False
        
        # Initialize components
        self.emulator = Emulator()
        self.vision = Vision(self.emulator)
        self.decision = Decision(self.vision)

        self.action_count = 0
        self.game_completed = False
        self.failure_count = 0
        self.stuck_count = 0
        self.last_actions = []  # Track recent actions to detect stuck states
        self.last_action_time = time.time()
        
        # Track timing statistics for performance monitoring
        self.timing_stats = {
            "vision": [],
            "decision": [],
            "action": []
        }

    def is_stuck(self):
        """Check if we're stuck in the same game state repeating the same actions"""
        if len(self.last_actions) < 10:
            return False
            
        if len(set(self.last_actions[-10:])) == 1:
            self.stuck_count += 1
            utils.log(f"Detected possible stuck state - same action {self.last_actions[-1]} repeated 10 times")
            return True
            
        return False

    def perform_recovery_action(self):
        """Attempt to recover from stuck states with a sequence of actions"""
        utils.log("Performing recovery sequence...")
        recovery_sequence = ["B", "START", "B", "A", "DOWN", "DOWN", "A", "B"]
        
        for action in recovery_sequence:
            utils.log(f"Recovery action: {action}")
            self.emulator.press_button(action)
            time.sleep(0.5)  # Reduced wait time for faster recovery
            
        self.stuck_count = 0
        self.last_actions = []

    def log_performance_stats(self):
        """Log performance statistics periodically"""
        if self.action_count % 50 == 0:
            stats = {}
            for key, values in self.timing_stats.items():
                if values:
                    stats[key] = {
                        "avg": sum(values) / len(values),
                        "min": min(values),
                        "max": max(values),
                        "total": len(values)
                    }
            
            utils.log(f"Performance stats after {self.action_count} actions:")
            for key, metrics in stats.items():
                utils.log(f"  {key}: avg={metrics['avg']:.3f}s, min={metrics['min']:.3f}s, max={metrics['max']:.3f}s")
            
            # Reset stats after logging
            self.timing_stats = {k: [] for k in self.timing_stats.keys()}

    def run(self):
        utils.log("Starting Pokémon Blue AI training with optimized models...")
        
        utils.log("Pressing START button to begin game...")
        self.emulator.press_button("START")
        time.sleep(5)  # Reduced wait time
        
        while not self.game_completed:
            try:
                start_time = time.time()
                
                # Get game state text
                vision_start = time.time()
                game_state_text = self.vision.get_game_state_text()
                vision_time = time.time() - vision_start
                self.timing_stats["vision"].append(vision_time)
                
                # Get next action
                decision_start = time.time()
                action = self.decision.get_next_action()
                decision_time = time.time() - decision_start
                self.timing_stats["decision"].append(decision_time)
                
                # Add action to history
                self.last_actions.append(action)
                if len(self.last_actions) > 20:
                    self.last_actions.pop(0)
                
                # Execute action
                action_start = time.time()
                self.emulator.press_button(action)
                action_time = time.time() - action_start
                self.timing_stats["action"].append(action_time)
                
                self.action_count += 1
                
                # Log action time and potential performance issues
                elapsed = time.time() - self.last_action_time
                self.last_action_time = time.time()
                
                if self.action_count % 10 == 0:
                    utils.log(f"Action {self.action_count}: {action} - Vision: {vision_time:.3f}s, Decision: {decision_time:.3f}s, Total: {elapsed:.3f}s")
                    self.log_performance_stats()
                
                # Check for stuck state and recovery
                if self.is_stuck() and self.stuck_count >= 3:
                    utils.log(f"Detected stuck state {self.stuck_count} times - attempting recovery")
                    self.perform_recovery_action()
                
                # Check for game completion
                if "Hall of Fame" in game_state_text:
                    utils.log(f"Game completed in {self.action_count} actions!")
                    self.game_completed = True
                
                # Dynamic polling interval based on game state
                if self.decision.current_state == "UNKNOWN":
                    time.sleep(config.POLLING_INTERVAL * 1.5)
                elif self.decision.current_state in ["TITLE_SCREEN", "DIALOGUE", "INTRO_SEQUENCE"]:
                    time.sleep(config.POLLING_INTERVAL * 0.7)  # Faster for simple states
                else:
                    time.sleep(config.POLLING_INTERVAL)
                    
            except Exception as e:
                self.failure_count += 1
                utils.log(f"Error during gameplay loop: {e}")
                if self.failure_count > 5:
                    utils.log("Too many consecutive failures. Restarting emulator...")
                    self.emulator.restart_emulator_if_closed()
                    self.failure_count = 0
                time.sleep(config.POLLING_INTERVAL * 2)

if __name__ == "__main__":
    # Try to free up memory before starting
    if torch.cuda.is_available():
        torch.cuda.empty_cache()
    
    PokemonTrainerAI().run() 
 
======================== 
memory_utils.py 
======================== 
"""
Utility functions for optimizing memory usage with PyTorch models.
This helps reduce VRAM consumption and allows models to run faster.
"""

import torch
import gc
import os
import psutil

def print_gpu_memory():
    """Print current GPU memory usage for monitoring."""
    if torch.cuda.is_available():
        for i in range(torch.cuda.device_count()):
            allocated = torch.cuda.memory_allocated(i) / 1024**2
            reserved = torch.cuda.memory_reserved(i) / 1024**2
            print(f"GPU Device {i}: {allocated:.2f} MB allocated, {reserved:.2f} MB reserved")
    else:
        print("No GPU available.")

def free_gpu_memory():
    """Free up unused GPU memory."""
    if torch.cuda.is_available():
        torch.cuda.empty_cache()
        gc.collect()
        print("Freed GPU memory.")
    else:
        print("No GPU available to free.")

def print_cpu_memory():
    """Print current CPU memory usage for this process."""
    process = psutil.Process(os.getpid())
    mem = process.memory_info().rss / 1024**2  # Convert bytes to MB
    print(f"CPU Memory usage: {mem:.2f} MB")

def free_cpu_memory():
    """Force garbage collection to free up CPU memory."""
    gc.collect()
    print("Forced garbage collection for CPU memory.")

if __name__ == "__main__":
    print("GPU Memory Info:")
    print_gpu_memory()
    print("\nCPU Memory Info:")
    print_cpu_memory()
    # Optionally free memory
    free_gpu_memory()
    free_cpu_memory()
 
 
======================== 
utils.py 
======================== 
import os
import cv2
import datetime
import config

def log(message):
    """Logs a message with a timestamp."""
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    log_message = f"[{timestamp}] {message}"
    print(log_message)
    log_file = os.path.join(config.LOG_DIR, "log.txt")
    with open(log_file, "a") as f:
        f.write(log_message + "\n")

def save_frame(frame, filename=None):
    """Saves a frame for debugging if enabled."""
    if config.SAVE_FRAMES:
        if filename is None:
            filename = f"frame_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
        filepath = os.path.join(config.FRAME_SAVE_DIR, filename)
        cv2.imwrite(filepath, frame)
        log(f"Saved frame: {filepath}")

def map_action_to_key(action):
    """Maps an action string to the emulator's keybinds."""
    return config.KEY_MAPPING.get(action.upper(), None)
 
 
======================== 
vision.py 
======================== 
import time
import utils
import config
import torch
from transformers import AutoProcessor, AutoModelForCausalLM
import cv2
import numpy as np
import os
from PIL import Image

class Vision:
    """
    Optimized Moondream-based vision class.
    This class captures the screen from the emulator and uses the Moondream model
    to analyze the game state.
    """
    def __init__(self, emulator=None):
        self.emulator = emulator
        self.device = "cuda" if torch.cuda.is_available() else "cpu"

        # Load Moondream processor and model with optimizations
        self.processor = AutoProcessor.from_pretrained(
            config.VISION_MODEL_PATH,
            trust_remote_code=True
        )
        
        self.model = AutoModelForCausalLM.from_pretrained(
            config.VISION_MODEL_PATH,
            revision="2025-01-09",
            trust_remote_code=True,
            device_map={"": self.device},
            torch_dtype=torch.float16,  # Use half precision
            load_in_8bit=True,          # Use 8-bit quantization to reduce memory
        )
        
        utils.log(f"Moondream model initialized on: {self.device} with 8-bit quantization")

        # Valid button actions
        self.valid_buttons = ["UP", "DOWN", "LEFT", "RIGHT", "A", "B", "START", "SELECT"]

        # Optimized Moondream prompt - shorter but still effective
        self.base_prompt = """
Describe this Pokémon Blue game screen. Focus on:
1. Game state (title screen, dialogue, battle, menu, or overworld)
2. Visible text or menu options
3. Character positions
4. Battle information if present
Be concise and specific.
"""

        # Image caching to avoid reprocessing identical frames
        self.image_cache = {}
        self.cache_limit = 5
        
        self.consecutive_title_screens = 0
        self.frames_captured = 0
        
        # Cache for encoded images to prevent redundant encoding
        self.encoded_cache = {}
        self.last_frame_hash = None

    def capture_screen(self):
        """
        Capture the emulator screen as a PIL image.
        """
        if not self.emulator:
            utils.log("WARNING: No emulator provided to Vision. Returning blank image.")
            return Image.new('RGB', (160, 144), color=(0, 0, 0))
        
        self.frames_captured += 1
        frame = self.emulator.capture_screen()
        
        # Save only every Nth frame to reduce disk I/O
        if self.frames_captured % config.FRAME_LOGGING_FREQUENCY == 0:
            utils.save_frame(frame, f"frame_{self.frames_captured}.png")
            
        # Convert BGR (OpenCV) to RGB and return PIL image
        return Image.fromarray(cv2.cvtColor(frame, cv2.COLOR_BGR2RGB))
    
    def _hash_image(self, image):
        """Create a simple hash for image caching."""
        # Convert to small grayscale for faster hashing
        img_small = image.resize((32, 32)).convert('L')
        img_array = np.array(img_small)
        return hash(img_array.tobytes())
    
    def get_game_state_text(self):
        """
        Return a descriptive text about the current screen with caching optimization.
        """
        image = self.capture_screen()
        image_hash = self._hash_image(image)
        
        # Check if this frame is in cache
        if image_hash in self.image_cache:
            utils.log("Using cached frame description")
            return self.image_cache[image_hash]
            
        # Check if this is the same as last frame
        if image_hash == self.last_frame_hash:
            utils.log("Frame unchanged, reusing last description")
            return self.image_cache.get(image_hash, "Game screen with no changes")
        
        self.last_frame_hash = image_hash
        
        # Fast path for encoded image cache
        if image_hash in self.encoded_cache:
            encoded = self.encoded_cache[image_hash]
            utils.log("Using cached encoded image")
        else:
            # Process image with the processor to get proper tensor input
            inputs = self.processor(images=image, return_tensors="pt").to(self.device)
            with torch.inference_mode():
                with torch.amp.autocast('cuda', enabled=True):
                    encoded = self.model.encode_image(**inputs)
            # Cache the encoded image
            if len(self.encoded_cache) >= self.cache_limit:
                oldest = next(iter(self.encoded_cache))
                del self.encoded_cache[oldest]
            self.encoded_cache[image_hash] = encoded
        
        # Generate caption with optimized settings.
        # Note: We now pass the prompt using the `text` parameter.
        with torch.inference_mode():
            caption = self.model.query(
                encoded,
                text=self.base_prompt,
                max_new_tokens=150,  # Limit token generation
                temperature=0.5,     # Lower temperature for more deterministic outputs
            )["answer"]
            
        utils.log(f"Moondream Screen Description: {caption}")
        
        # Update cache
        if len(self.image_cache) >= self.cache_limit:
            oldest = next(iter(self.image_cache))
            del self.image_cache[oldest]
        self.image_cache[image_hash] = caption
        
        # Track title screen occurrences
        if "title" in caption.lower() or "blue version" in caption.lower():
            self.consecutive_title_screens += 1
            utils.log(f"Title screen detection count: {self.consecutive_title_screens}")
        else:
            self.consecutive_title_screens = 0
            
        return caption

    def get_next_action(self, task_instruction=None):
        """
        Use the Moondream model to choose the next button press.
        Optimized with fast paths and more efficient generation settings.
        """
        # Title screen fast path
        if self.consecutive_title_screens >= 2:
            utils.log("Multiple title screens detected. Forcing START button.")
            return "START"
        
        image = self.capture_screen()
        image_hash = self._hash_image(image)
        
        # Get or create encoded image
        if image_hash in self.encoded_cache:
            encoded = self.encoded_cache[image_hash]
            utils.log("Using cached encoded image for action generation")
        else:
            inputs = self.processor(images=image, return_tensors="pt").to(self.device)
            with torch.inference_mode():
                with torch.amp.autocast('cuda', enabled=True):
                    encoded = self.model.encode_image(**inputs)
            if len(self.encoded_cache) >= self.cache_limit:
                oldest = next(iter(self.encoded_cache))
                del self.encoded_cache[oldest]
            self.encoded_cache[image_hash] = encoded
            
        # Use task instruction if provided, otherwise use default prompt
        if task_instruction:
            prompt = f"""
You are playing Pokémon Blue. Choose a button based on this instruction:
{task_instruction}
Reply with ONLY one button: UP, DOWN, LEFT, RIGHT, A, B, START, SELECT
"""
        else:
            prompt = """
You are playing Pokémon Blue. Choose ONE button to press:
If you see title screen: START
If you see text/dialogue: A
If in menu: UP/DOWN to navigate, A to select
If in overworld: UP/DOWN/LEFT/RIGHT to move

Reply with ONLY one button: UP, DOWN, LEFT, RIGHT, A, B, START, SELECT
"""
        # Generate with optimized settings.
        # Pass the prompt using the `text` parameter.
        with torch.inference_mode():
            response = self.model.query(
                encoded,
                text=prompt,
                temperature=0.5,
                max_new_tokens=15,
                top_p=0.85
            )["answer"]
            
        utils.log(f"Moondream raw decision: {response}")
        action = response.strip().upper()
        
        # Extract button by direct pattern matching
        for button in self.valid_buttons:
            if button in action:
                utils.log(f"Extracted button '{button}' from '{action}'")
                return button
                
        # Title screen override
        if "TITLE" in action or "BLUE VERSION" in action:
            utils.log("Title screen text detected in response, overriding to START")
            return "START"
        
        # Default to "redo" if no valid button found - NEEDED FOR AI PLAYTHROUGH
        utils.log(f"No valid button in '{action}'. Defaulting to RETRYING.")
        return self.get_next_action()  # Recursive call to try again
 
 
